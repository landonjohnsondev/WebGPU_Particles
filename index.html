<!--
Extra:
• Level 1
• Replay makes strafe go into sky?
• Delta time system?
• Move with grass blocks?
• Take damage red flash?
-->

<HTML>
	<HEAD>
		<BODY style="
			margin: 0;
			padding: 0;
			overflow: hidden; /* prevents scrollbars */
			height: 100%;
			width: 100%;
		"> 
			<!-- this will have issues if window is resized -->
			<canvas id="myCanvas" style="display: block; width: 100%; height: 100%;" width="1500" height="750"></canvas>
			<h1 id="title">Explosive Maneuvers</h1>
			
			<button id="start" style="top: 40%;" onclick="GPU.HideTitleScreen(); GPU.StartGame()">
				<h1 id="startText">Start Game</h1>
			</button>

			<button id="credits" style="top: 50%;" onclick="GPU.HideTitleScreen(); GPU.ShowCredits()">
				<h1 id="creditsText">Credits</h1>
			</button>

			<h1 id="Landon" class="centerText" style="top: 40%;">Landon Johnson</h1>
			<h1 id="Jasmine" class="centerText" style="top: 50%;">Jasmine Rodriguez</h1>

			<button id="back" style="right: 75%; top: 75%;" onclick="GPU.HideCredits(); GPU.ShowTitleScreen()">
				<h1>Back</h1>
			</button>			

			<h1 id="win" class="centerText" style="top: 45%; font-size: 30pt;">You Win!</h1>
			<button id="returnBtn" style="right: 75%; top: 75%;" onclick="GPU.HideWinScreen(); GPU.ShowTitleScreen(); GPU.ResetGame();">
				<h1 id="returnText">Main Menu</h1>
			</button>

			<img src="heart.png" id="heart1" class="heart" style="top: 80%; left: 77%">
			<img src="heart.png" id="heart2" class="heart" style="top: 80%; left: 85%">
			<img src="heart.png" id="heart3" class="heart" style="top: 80%; left: 93%">
						
			<!-- https://pixabay.com/music/build-up-scenes-dead-by-daylight-10243/ -->
			<audio id="titleMusic" src="Audio/TitleMusic.mp3" loop autoplay></audio>
			<!-- https://pixabay.com/sound-effects/ouch-oof-hurt-sound-effect-262616/ -->
			<audio id="takeDamage" src="Audio/TakeDamage.mp3"></audio>
			<!-- https://pixabay.com/music/video-games-to-the-death-159171/ -->
			<audio id="bossMusic" src="Audio/BossMusic.mp3" loop autoplay></audio>
			<!-- https://pixabay.com/music/crime-scene-infiltrated-418159/ -->
			<audio id="levelMusic" src="Audio/LevelMusic.mp3" loop autoplay></audio>

			<!-- https://pixabay.com/sound-effects/epic-movie-trailer-hit-sharp-metal-spike-2-dry-386282/ -->
			<audio id="hitSpikes" src="Audio/HitSpikes.mp3"></audio>

			<!-- https://pixabay.com/sound-effects/squeak-metal-ps-025-389414/ -->
			<audio id="metalMove" src="Audio/MetalMove.mp3"></audio>

			<!-- https://pixabay.com/sound-effects/087014-jm-impact-01c-89435/ -->
			<audio id="shootPlatform" src="Audio/ShootPlatform.mp3"></audio>

			<audio id="tntSizzle" src="Audio/TntSizzle.mp3"></audio>			

			<audio id="creeperHurt" src="Audio/CreeperHurt.mp3"></audio>
			<!-- https://pixabay.com/sound-effects/loud-explosion-425457/ -->
			<audio id="boom" src="Audio/Explosion.mp3"></audio>

			<!-- small tnt -->
			<!-- https://sketchfab.com/3d-models/small-tnt-b7a5bd67fc594400ba0d7cb46651b4c3 -->
		</BODY>
	
		<link rel="stylesheet" href="styles.css">
		<script src="./BasicGameObjects.js"></script>
		<script src="./Models.js"></script>
		<script src="./Textures.js"></script>
		<script src="./Parsing.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

		<!-- All classes, and WebGPU will be defined (or imported) here -->
		 <!-- WRITE MAT4 MATRICES DIRECTLY INTO BUFFER, DON'T REORDER -->
		<SCRIPT>						
			var secondTimer = 0.0;
			var lastSecondTime;
			var performancePercentage = 1.0;
			
			var startedMusic = false;
		
			function FrameUpdate()
			{				
				GPU.GetControllerInput();
				GPU.UpdateAll();
				GPU.RenderAll(GPU.resolution);
							
				GPU.loopsInLastSecond++;
								
				//for initialization
				if(lastSecondTime == undefined)
					lastSecondTime = performance.now();
				
				var timePassed = (performance.now() - lastSecondTime) / 1000;				
				if(timePassed > 1)
				{
					lastSecondTime = performance.now();
					performancePercentage = GPU.loopsInLastSecond / 60.0;
					GPU.loopsInLastSecond = 0;
					//console.log("performancePercentage in frameUpdate: " + performancePercentage);
				}
							
				requestAnimationFrame(FrameUpdate);
			}

			//making this a global function so it can be called after all objects have been made
			function InitExplodePositions(dummyPos)
			{
				dummyPos.push(1);

				for(let i = 0; i < GPU.numExplodePositions; i++)
				{									
					let initialOffset = GPU.explodePosInitialOffset;					
					for(var j in GPU.Visual)
						GPU.device.queue.writeBuffer(GPU.Visual[j].uniformBuffer, initialOffset + (16 * i), new Float32Array(dummyPos));
					for(var j in GPU.Solid)
						GPU.device.queue.writeBuffer(GPU.Solid[j].uniformBuffer, initialOffset + (16 * i), new Float32Array(dummyPos));
					for(var j in GPU.Trigger)
						GPU.device.queue.writeBuffer(GPU.Trigger[j].uniformBuffer, initialOffset + (16 * i), new Float32Array(dummyPos));
				}
			}			
							
			//when a crater is made, initialize its explodePositions to the current GPU explodePositions
			//then write the crater's new explode pos to all objects
			function SetExplodePos(pos, idx)
			{					
				pos.push(1); //make pos a vec4f to ensure it is 16 bytes long
				console.log("parse for sphere");
				var result = ParseVertices(window.sphere, window.sphereMtl);
				var sphere = GPU.CreateObject(0, Crater, pos, [0,0,0], [8,8,8], result, window.grassTexture, window.grassNormals);
				
				//to set AND retrieve current explodePositions as craters are made, keep array of explodePositions in WebGPU class
				GPU.explodePos[idx] = pos;				
				console.log("set explodePos[" + idx + "] to " + pos);				
				
				//idx represents the tnt number it is, like 0th tnt or 1st tnt for explodePos[0] or explodePos[1] in shader
				let initialOffset = GPU.explodePosInitialOffset;				
				for(var i in GPU.Visual)
					GPU.device.queue.writeBuffer(GPU.Visual[i].uniformBuffer, initialOffset + (16 * idx), new Float32Array(pos));
				for(var i in GPU.Solid)
					GPU.device.queue.writeBuffer(GPU.Solid[i].uniformBuffer, initialOffset + (16 * idx), new Float32Array(pos));
				for(var i in GPU.Trigger)
					GPU.device.queue.writeBuffer(GPU.Trigger[i].uniformBuffer, initialOffset + (16 * idx), new Float32Array(pos));
			}				

			function ClearExplosions()
			{				
				GPU.explodePos = [];						
				InitExplodePositions([9999,9999,9999]);
				var craters = GPU.GetObjectsOfType(Crater);
				for(let i = 0; i < craters.length; i++)
				{
					GPU.DestroyObject(craters[i].id);
				}				
			}

			class PointLight extends Light
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);							
					this.pointLightIndex = GPU.GetObjectsOfType(PointLight).length;					
													
					//number of point lights
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 12, new Uint32Array([this.pointLightIndex+1]));
					
					this.moveTime = 2.0;
					this.moveTimer = 2.0;
					this.curDir = -1;
					this.moveSpeed = 0.4;					
				}
				
				Update() 
				{
					this.ApplySceneGraph();

					if(this.curDir == -1)
						this.localPos[0] -= this.moveSpeed;
					else if(this.curDir == 1)
						this.localPos[0] += this.moveSpeed;

					this.moveTimer -= (1.0/60.0);

					if(this.moveTimer < 0)
					{
						this.curDir *= -1;
						this.moveTimer = this.moveTime;
					}					
				}

				Render(pass)
				{					
					pass.setBindGroup(0, this.pLightGroup);
										
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 4, new Float32Array([this.specularity]));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (32 + 32*this.pointLightIndex), new Float32Array(this.pos));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (48 + 32*this.pointLightIndex), new Float32Array(this.color));

					GPU.device.queue.writeBuffer(this.uniformBuffer, 0, new Float32Array([
							this.worldMatrix[0][0],this.worldMatrix[1][0],this.worldMatrix[2][0],this.worldMatrix[3][0],
							this.worldMatrix[0][1],this.worldMatrix[1][1],this.worldMatrix[2][1],this.worldMatrix[3][1],
							this.worldMatrix[0][2],this.worldMatrix[1][2],this.worldMatrix[2][2],this.worldMatrix[3][2],
							this.worldMatrix[0][3],this.worldMatrix[1][3],this.worldMatrix[2][3],this.worldMatrix[3][3],
						]));					
						GPU.device.queue.writeBuffer(this.uniformBuffer, 64, new Float32Array(this.rot));
				}
			}

			class SpotLight extends Light
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);					
					this.spotLightIndex = GPU.GetObjectsOfType(SpotLight).length;					
					
					//number of spot lights
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 16, new Uint32Array([this.spotLightIndex+1]));
					this.moveSpeed = 0.01;
				}
				
				Update()
				{
					this.ApplySceneGraph();
					this.transform.doRotations(this.localRot);
					this.localRot[1] += this.moveSpeed;			
				}				

				Render(commandPass)
				{
					commandPass.setBindGroup(0, this.pLightGroup);
									
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 4, new Float32Array([this.specularity]));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (352 + 48*this.spotLightIndex), new Float32Array(this.pos));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (368 + 48*this.spotLightIndex), new Float32Array(this.transform.forward));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (384 + 48*this.spotLightIndex), new Float32Array(this.color));															
				}
			}

			class DirectionalLight extends Light
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);					
					this.dirLightIndex = GPU.GetObjectsOfType(DirectionalLight).length;				
										
					//number of dir lights
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 20, new Uint32Array([this.dirLightIndex+1]));

					this.moveTime = 2.0;
					this.moveTimer = 2.0;
					this.curDir = -1;
					this.moveSpeed = 0.01;
				}
				
				Update()
				{
					if(this.curDir == -1)
						this.localRot[1] -= this.moveSpeed;
					else if(this.curDir == 1)
						this.localRot[1] += this.moveSpeed;

					this.moveTimer -= (1.0/60.0);

					if(this.moveTimer < 0)
					{
						this.curDir *= -1;
						this.moveTimer = this.moveTime;
					}
					this.transform.doRotations(this.localRot);
				}

				Render(commandPass)
				{														
					commandPass.setBindGroup(0, this.pLightGroup);										

					//GPU.device.queue.writeBuffer(GPU.lightBuffer, 4, new Float32Array([this.specularity]));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (832 + 32*this.dirLightIndex), new Float32Array(this.transform.forward));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (848 + 32*this.dirLightIndex), new Float32Array([this.color[0], this.color[1], this.color[2], 0.0]));					
				}
			}

			class CustomObj extends GameObject
			{
				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{					
					super(pos, rot, scale);

					if(parserData != undefined)
					{						
						this.vertices = parserData[0];
						this.indexes = parserData[1];

						//will probably put this in a uniform later						
						this.Ka = parserData[2];
						this.Ks = parserData[3];
						this.specularity = parserData[4];						
					}

					this.isTrigger = false;
										
					this.vertexBuffer = GPU.device.createBuffer({
						label: "verticeBuffer",
						size: this.vertices.byteLength,
						usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.vertexBuffer, /*bufferOffset=*/0, this.vertices);				
					
					this.indexBuffer = GPU.device.createBuffer({
						label: "indexBuffer",
						size: this.indexes.byteLength,
						usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.indexBuffer, /*bufferOffset=*/0, this.indexes);

					this.specularity = 1;
					
					
					this.mainBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(0),
						label: 'customObjMainGroup',
						entries:
						[
							{ binding: 0, resource: { buffer: this.uniformBuffer }},
							{ binding: 1, resource: { buffer: GPU.lightBuffer}},
						],
					});							

					this.SetupTextures(rawTexture, normalMap);
					this.textureBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(2),
						label: 'customObjTextureGroup',
						entries:
						[																
							{ binding: 0, resource: this.textureObj.createView() },							
							{ binding: 1, resource: GPU.sampler },
							{ binding: 2, resource: this.normalTextureObj.createView() },
						],
					});
					this.timer = 0.0;
					
					this.ApplySceneGraph();
					this.SetCollisionEdges();
					this.InitExplodePositions();
				}

				SetCollisionEdges()
				{								
					let minX = 9999;
					let maxX = -9999;

					let minY = 9999;
					let maxY = -9999;

					let minZ = 9999;
					let maxZ = -9999;
					
					for(let i = 0; i < this.vertices.length; i += GPU.vertexStride)
					{
						if(this.vertices[i] < minX)						
							minX = this.vertices[i];						
						if(this.vertices[i] > maxX)						
							maxX = this.vertices[i];					

						if(this.vertices[i+1] < minY)
							minY = this.vertices[i+1];						
						if(this.vertices[i+1] > maxY)
							maxY = this.vertices[i+1];

						if(this.vertices[i+2] < minZ)
							minZ = this.vertices[i+2];
						if(this.vertices[i+2] > maxZ)
							maxZ = this.vertices[i+2];
					}
					
					//console.log("minX before scale: " + minX);
					minX *= this.scale[0];
					maxX *= this.scale[0];

					minY *= this.scale[1];
					maxY *= this.scale[1];					

					minZ *= this.scale[2];
					maxZ *= this.scale[2];									

					// console.log("minX: " + minX + ", maxX: " + maxX);
					// console.log("minY: " + minY + ", maxY: " + maxY);
					// console.log("minZ: " + minZ + ", maxZ: " + maxZ);				

					this.leftX = minX;
					this.rightX = maxX;
					this.topY = maxY;
					this.bottomY = minY;
					this.farZ = maxZ;
					this.nearZ = minZ;					
				}								

				Update()
				{	
					this.ApplySceneGraph();
					var hitSomething = this.Move();					
				}

				Render(pass)
				{
					this.IndexDraw(pass);
				}
			}

			class Camera extends GameObject
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);					

					this.camBuff = GPU.device.createBuffer({
						label: 'camBuffer',
						size: 32,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					});

					this.camGroup = GPU.device.createBindGroup({
						layout: GPU.pipeline.getBindGroupLayout(1),
						label: 'camera',
						entries: [
							{ binding: 0, resource: {buffer: this.camBuff}},
						],
					});					
					
					this.moveSpeed = 0.12;
					this.strafeSpeed = 0.08;
					this.rotSpeed = 0.04;	

					this.isTrigger = false;
					//this.collisionRadius = 5;

					this.camRadius = 0.5;
					this.sideLength = 1.5;
					this.leftX = -this.camRadius;
					this.rightX = this.camRadius;
					this.bottomY = -this.sideLength;
					this.topY = this.sideLength;
					this.nearZ = -this.camRadius;
					this.farZ = this.camRadius;

					//set isLaunchable to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 160, new Uint32Array([1]));
					this.vel = [0,0,0];
					this.grounded = false;
					this.jumpStrength = 0.4;

					//this.respawnPos = pos;
					this.hp = 3;

					this.stickDeadzone = 0.05;

					this.invincibilityTimer = 0.0;
					this.invincibilityTime = 0.5;				
				}

				TakeDamage(damage)
				{
					if(this.isInvincible)
						return;

						this.isInvincible = true;
					
					this.hp -= damage;					
					document.getElementById("takeDamage").play();
					if(this.hp <= 2)
						document.getElementById("heart3").style.visibility = "hidden";

					if(this.hp <= 1)
					{
						document.getElementById("heart2").style.visibility = "hidden";
						document.getElementById("heart3").style.visibility = "hidden";
					}	
					
					if(this.hp <= 0)
					{
						document.getElementById("heart1").style.visibility = "hidden";
						document.getElementById("heart2").style.visibility = "hidden";
						document.getElementById("heart3").style.visibility = "hidden";

						GPU.GetObjectOfType(Fade).fadeState = "fadeOut";
						GPU.GetObjectOfType(Fade).isFirstFade = true;		
						this.standingOnCrater = false;
						this.ignoreCollision = false;
						this.launchVec = undefined;
						this.vel = [0,0,0];

						var flames = GPU.GetObjectsOfType(Flame);
						for(let i = 0; i < flames.length; i++)
						{
							GPU.DestroyObject(flames[i].id);
						}

						ClearExplosions();					

						//first destroy all fire to unfuse any tnt
						//fade to black
						//reset cam hp
						//reset cam launch vec and other cam vars since it doesn't get destroyed							
						//DestroyAllObjects (besides cam and fade)
						//rerun SlowStart
						//fade back in		
					}
				}

				UpdateCollision()
				{				
					//leftX *= 1 at rotY=0;	
					//leftX *= 0.5 at rotY=45deg;

					//fix this tomorrow or test getting new min/max vertices at each position
					this.leftX *= math.cos(this.rot[1]);
					this.rightX *= math.cos(this.rot[1]);
					this.bottomY *= math.cos(this.rot[1]);
					this.topY *= math.cos(this.rot[1]);
					this.nearZ *= math.cos(this.rot[1]);
					this.farZ *= math.cos(this.rot[1]);

					//how to check if diagonal line intersects with other cube?
					//get leftmost and 2nd leftmost vertices, 
					
					//use sphere for camera?
				}

				Update()
				{					
					if(!GPU.gameLoaded || GPU.gameWon)																
						return;					

					//dumb code to load boss level
					if(this.pos[1] < -50 && GPU.GetObjectOfType(Fade).level == 1)
					{
						GPU.GetObjectOfType(Fade).fadeState = "fadeOut";
						GPU.GetObjectOfType(Fade).level = 2;
						GPU.GetObjectOfType(Fade).isFirstFade = true;
					}

					this.ApplySceneGraph();					
					this.transform.doRotations(this.rot);

					var leftX = this.LeftStickX();
					var leftY = this.LeftStickY();
					var rightX = this.RightStickX();
					var rightY = this.RightStickY();

					if(this.isInvincible)
					{
						this.invincibilityTimer += (1/60);
						if(this.invincibilityTimer > this.invincibilityTime)
						{
							this.isInvincible = false;
							this.invincibilityTimer = 0.0;
						}
					}

					//reset x and z vel every frame, but retain gravity					
					//while launching, cap x and z speed to max(launch speed, movement speed)

					this.vel[1] += (1/60) * -0.8;					
					if(this.launchVec == undefined)
					{
						this.vel[0] = 0;
						this.vel[2] = 0;
					}
					else
					{
						//useless but here for readability
						this.vel[0] = this.vel[0];
						this.vel[1] = this.vel[1];
						this.vel[2] = this.vel[2];						
					}					

					//if a stick is being held
					var rotIntensity = (math.abs(leftX) > this.stickDeadzone) ? math.abs(leftX) : 1.0;
					if(GPU.CheckKey('D') || this.LeftStickX() > this.stickDeadzone || this.RightDpadHeld())
						this.rot[1] += this.rotSpeed * rotIntensity;
					if(GPU.CheckKey('A') || this.LeftStickX() < -this.stickDeadzone || this.LeftDpadHeld())
						this.rot[1] -= this.rotSpeed * rotIntensity;					

					if( (GPU.CheckKey(' ') || this.AHeld()) && this.grounded)
					{
						this.vel[1] += this.jumpStrength;
						this.grounded = false;
					}
					
					var moveIntensity = (math.abs(leftY) > this.stickDeadzone) ? math.abs(leftY) : 1.0;
					if(GPU.CheckKey('W') || this.LeftStickY() > this.stickDeadzone || this.UpDpadHeld())
					{
						var newVel = [ this.vel[0], this.vel[1], this.vel[2] ];
						newVel[0] += this.transform.forward[0] * this.moveSpeed * moveIntensity;
						newVel[1] += this.transform.forward[1] * this.moveSpeed * moveIntensity;
						newVel[2] += this.transform.forward[2] * this.moveSpeed * moveIntensity;

						//always add vel if no launchVec. if launchVec, only allows lower speeds
						if(this.launchVec == undefined || math.hypot(newVel) < math.hypot(this.vel))
							this.vel = [newVel[0], newVel[1], newVel[2] ];
					}
					if(GPU.CheckKey('S') || this.LeftStickY() < -this.stickDeadzone || this.DownDpadHeld())
					{
						var newVel = [ this.vel[0], this.vel[1], this.vel[2] ];
						newVel[0] -= this.transform.forward[0] * this.moveSpeed * moveIntensity;
						newVel[1] -= this.transform.forward[1] * this.moveSpeed * moveIntensity;
						newVel[2] -= this.transform.forward[2] * this.moveSpeed * moveIntensity;

						if(this.launchVec == undefined || math.hypot(newVel) < math.hypot(this.vel))													
							this.vel = [ newVel[0], newVel[1], newVel[2] ];						
					}					

					//STRAFE CONTROLS
					//Left key pressed. idk why left key is % with Towle's code
					var strafeIntensity = (math.abs(rightX) > this.stickDeadzone) ? math.abs(rightX) : 1.0;
					if(GPU.CheckKey('%') || this.RightStickX() < -this.stickDeadzone)
					{						
						var newVel = [ this.vel[0], this.vel[1], this.vel[2] ];
						newVel[0] -= this.strafeSpeed * this.transform.right[0] * strafeIntensity;
						newVel[1] -= this.strafeSpeed * this.transform.right[1] * strafeIntensity;
						newVel[2] -= this.strafeSpeed * this.transform.right[2] * strafeIntensity;

						if(this.launchVec == undefined || math.hypot(newVel) < math.hypot(this.vel))						
							this.vel = [ newVel[0], newVel[1], newVel[2] ];						
					}
					//Right key pressed. this is right key apparently
					if(GPU.CheckKey('\'') || this.RightStickX() > this.stickDeadzone)
					{						
						var newVel = [ this.vel[0], this.vel[1], this.vel[2] ];
						newVel[0] += this.strafeSpeed * this.transform.right[0] * strafeIntensity;
						newVel[1] += this.strafeSpeed * this.transform.right[1] * strafeIntensity;
						newVel[2] += this.strafeSpeed * this.transform.right[2] * strafeIntensity;

						if(this.launchVec == undefined || math.hypot(newVel) < math.hypot(this.vel))						
							this.vel = [ newVel[0], newVel[1], newVel[2] ];													
					}										
														
					var ignoreCollision = false;
					var standingOnCrater = false;										

					this.closestCraterPos = this.ClosestCraterPos();
					if(this.closestCraterPos != undefined)
					{
						this.xzDistToCrater = this.XZDistance(this.pos, this.closestCraterPos);
						this.newPos = [ this.pos[0] + this.vel[0], this.pos[1] + this.vel[1], this.pos[2] + this.vel[2] ];
						this.newXZDistToCrater = this.XZDistance(this.newPos, this.closestCraterPos);
					}

					//falling into crater, 6.5 is kinda hardcoded based on camRadius so you don't fall over and over
					if(this.closestCraterPos != undefined && 
						this.VectorDistance(this.pos, this.closestCraterPos) < 6.5)
					{						
						ignoreCollision = true;
					}
					//moving along crater, allow jumping
					else if(this.closestCraterPos != undefined && 
						this.pos[1] < this.closestCraterPos[1] &&
						this.vel[1] < 0.4 &&
						this.Between( this.VectorDistance(this.pos, this.closestCraterPos), 6.5, 8.5 ) )
					{						
						standingOnCrater = true;					
					}
					//exiting crater
					else if( this.closestCraterPos != undefined && 
							this.Between(this.pos[1], this.closestCraterPos[1] - 0.5, this.closestCraterPos[1] + 0.5) &&
							this.xzDistToCrater < 8.5 && 
							this.newXZDistToCrater > this.xzDistToCrater)
					{
						
						ignoreCollision = true;			
						//hard-coded fix for moving above crater						
						this.localPos[1] = this.closestCraterPos[1] + this.sideLength + 0.01;
					}										
					
					var collision = this.MoveAndSlide(ignoreCollision, standingOnCrater);
					// if(collision instanceof CustomObj && collision.TopY() < this.BottomY())
					// {
					// 	this.launchStopOn = true;
					// 	this.launchStopTimer = 0.0;
					// }

					// if(this.launchStopOn)
					// {
					// 	this.launchStopTimer += (1/60);
					// 	if(this.launchStopTimer > this.launchStopTime)
					// 	{
					// 		console.log("remove launch vec");
					// 		this.launchVec = undefined;
					// 		this.launchStopTimer = 0.0;
					// 		this.launchStopOn = false;
					// 	}
					// 	console.log("launchStopTimer: " + this.launchStopTimer);
					// }
					//zero explosion speed once camera hits a solid
					//don't let collisions below stop launch speed
					if( collision != undefined || standingOnCrater) // && collision.TopY() > this.BottomY())
						this.launchVec = undefined;
				}

				ClosestCraterPos()
				{								

					let minDist = 9999;
					let closestIdx = -1;
					for(let i = 0; i < GPU.numExplodePositions; i++)
					{
						if(GPU.explodePos[i] == undefined)
							continue;

						var dist = this.VectorDistance(this.pos, GPU.explodePos[i]);
						if(dist < minDist)
						{
							minDist = dist;
							closestIdx = i;
						}
					}

					if(GPU.explodePos[closestIdx] == undefined)
						return undefined;

					return [ GPU.explodePos[closestIdx][0], GPU.explodePos[closestIdx][1], GPU.explodePos[closestIdx][2] ];
				}

				GetCraterY(x, z)
				{
					if(this.closestCraterPos == undefined)
						return undefined;

					var craterXZ = [x, this.closestCraterPos[1], z];
					var xzDistToCrater = this.VectorDistance(craterXZ, this.closestCraterPos);
					xzDistToCrater = math.min(xzDistToCrater, 8);
					var craterY = this.closestCraterPos[1] - math.sqrt(64 - xzDistToCrater**2);
					return craterY;
				}

				Render(commandPass)
				{					
					commandPass.setBindGroup(1, this.camGroup);
					GPU.device.queue.writeBuffer(this.camBuff, 0, new Float32Array(this.pos));
					GPU.device.queue.writeBuffer(this.camBuff, 16, new Float32Array(this.rot));
				}
			}

			class Smoke extends GameObject
			{
				constructor(pos, rot, scale, fade=0, rawTexture, normalMap)
				{
					super(pos, rot, scale);				

					this.fade = fade;

					let maxDim = 1;
					let maxU = 0.5;
					let maxV = 1;
					//these triangles form a square, which is the area for the fire "texture"		
					this.vertices = new Float32Array([
						 -maxDim,maxDim,0, 0,0,0, -maxU, maxV, 0,0,0,0,0,0,0,0,0,0,
						-maxDim,-maxDim,0, 0,0,0, -maxU,-maxV, 0,0,0,0,0,0,0,0,0,0,
						  maxDim,maxDim,0, 0,0,0,  maxU, maxV, 0,0,0,0,0,0,0,0,0,0,
						 
						-maxDim,-maxDim,0, 0,0,0,  maxU,-maxV, 0,0,0,0,0,0,0,0,0,0,
						 maxDim,-maxDim,0, 0,0,0, -maxU,-maxV, 0,0,0,0,0,0,0,0,0,0,
						  maxDim,maxDim,0, 0,0,0, -maxU, maxV, 0,0,0,0,0,0,0,0,0,0,
					]);
					
					this.vertexBuffer = GPU.device.createBuffer({
						label: "verticeBuffer",
						size: this.vertices.byteLength,
						usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.vertexBuffer, 0, this.vertices);					
					
					if(this.fade == 1)
					{
						this.timer = 0.0;
					}
					else
					{
						let randStartTime = math.random()*100;
						this.timer = randStartTime;
					}								
					
					this.billboardGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(0),
						label: "billboardGroup",
						entries:
						[
							{ binding: 0, resource: {buffer: this.uniformBuffer}},
							{ binding: 1, resource: {buffer: GPU.lightBuffer}},
						],
					});					
					
					this.SetupTextures(rawTexture, normalMap);
					this.textureBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(2),
						label: 'customObjTextureGroup',
						entries:	
						[																
							{ binding: 0, resource: this.textureObj.createView() },							
							{ binding: 1, resource: GPU.sampler },
							{ binding: 2, resource: this.normalTextureObj.createView() },
						],
					});					
										
					//assumes camera has already been made
					this.camera = GPU.GetObjectOfType(Camera);					
										
					//set isSmoke to true in the shader
					GPU.device.queue.writeBuffer(this.uniformBuffer, 128, new Uint32Array([1]));
				}												
				
				Update()
				{					
					this.ApplySceneGraph();
					this.timer += (1/60);								
					
					//make flame face camera for billboarded effect if parent is null, otherwise, fire takes care of it
					if(this.parent == null)
						this.localRot[1] = this.camera.rot[1];

					this.transform.doRotations(this.localRot);
					
					// If we want smoke to fade, then wait 0.5 secs
					if(this.fade == 1 && this.timer >= 0.5)
					{
						// shrink the smoke
						this.localScale[0] -= 0.02;
						this.localScale[1] -= 0.02;
						this.localScale[2] -= 0.02;
						
						if (this.localScale[1] <= 0)
						{
							GPU.DestroyObject(this.id);
						}
					}
				}				
											
				Render(commandPass)
				{					
					this.ParticleDraw(commandPass);		
				}
			}
			
			class Flame extends GameObject
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);	
										
					//these triangles form a square, which is the area for the fire "texture"
					let maxDim = 0.5;
					let maxUV = 1;
					this.vertices = new Float32Array([
						//near face
						-maxDim,  maxDim,  0,  0,0,0,  -maxUV,  maxUV, 0,0,0,0,0,0,0,0,0,0,
						-maxDim, -maxDim, 0,  0,0,0,  -maxUV, -maxUV, 0,0,0,0,0,0,0,0,0,0,
						maxDim,  maxDim,  0,  0,0,0,   maxUV,  maxUV, 0,0,0,0,0,0,0,0,0,0,

						-maxDim, -maxDim, 0, 0,0,0,   maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						maxDim, -maxDim, 0, 0,0,0,  -maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						maxDim,  maxDim, 0, 0,0,0,  -maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
					]);
					
					this.vertexBuffer = GPU.device.createBuffer({
						label: "verticeBuffer",
						size: this.vertices.byteLength,
						usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.vertexBuffer, 0, this.vertices);

					let randStartTime = math.random()*100;
					this.timer = randStartTime;
					
					this.billboardGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(0),
						label: "flameGroup",
						entries:
						[
							{ binding: 0, resource: {buffer: this.uniformBuffer}},
							{ binding: 1, resource: {buffer: GPU.lightBuffer}},
						],
					});					
					
					//even though fire doesn't use texture bindings, the group needs to be bound since
					//group(0) interacts with the textures in group(2) in the shader
					this.SetupTextures(undefined, undefined);
					this.textureBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(2),
						label: 'customObjTextureGroup',
						entries:
						[																
							{ binding: 0, resource: this.textureObj.createView() },			
							{ binding: 1, resource: GPU.sampler },
							{ binding: 2, resource: this.normalTextureObj.createView() },
						],
					});
					
					this.flameSpeedPerSecond = 2.2;
					this.visualSpeed = 1.0;

					this.camera = GPU.GetObjectOfType(Camera);					
					
					//set isFlame to true in the shader
					GPU.device.queue.writeBuffer(this.uniformBuffer, 124, new Uint32Array([1]));			

					this.smoke = GPU.CreateObject(2, Smoke, [0,1,0], [0,0,0], [0.8, 0.8, 0.8], 0, 0, 0, 0);
					this.smoke.SetParent(this);
				}																				

				SetGoalPos(goalPos)
				{											
					this.goalPos = goalPos;
					//console.log("goalPos: " + goalPos);

					//not using the variables from the rest of this function atm
					this.burnDistance = this.VectorDistance(this.pos, goalPos);
					this.ropeBurnTime = this.burnDistance / this.flameSpeedPerSecond;

					this.xChangeToGoal = goalPos[0] - this.pos[0];
					this.yChangeToGoal = goalPos[1] - this.pos[1];
					this.zChangeToGoal = goalPos[2] - this.pos[2];
				}

				SetFlameSpeed(speed)
				{
					this.visualSpeed = speed;
				}

				//sets goal pos to rightmost goal vertice found
				StartRope(rope)
				{
					this.SetParent(rope);
					//need to do this otherwise the flame's transform and goal is messed up lol
					this.ApplySceneGraph();
					//set isFlashing of tnt parent to true
					rope.parent.StartFlashing();

					this.pathPositions = rope.GetSortedPathPositions();

					this.goalIdx = this.pathPositions.length-1;
					this.goalPos = this.pathPositions[this.goalIdx];
					this.SetGoalPos(this.goalPos);
				}
				
				Update()
				{
					//console.log("flame parent: " + this.parent);
					this.ApplySceneGraph();
					this.timer += (1/60) * this.visualSpeed;

					this.localScale[0] *= 0.995;
					this.localScale[1] *= 0.995;
					this.localScale[2] *= 0.995;

					if(this.localScale[0] < 0)
						GPU.DestroyObject(this.id);

					//make flame face camera for billboarded effect
					this.localRot[1] = this.camera.rot[1];
					this.transform.doRotations(this.localRot);
					
					if(this.goalPos == undefined)
						return;

					if(this.VectorDistance(this.pos, this.goalPos) > 0.05)
					{
						//get dirToGoal every frame to prevent flame from going offtrack
						var dirToGoal = [0,0,0];
						dirToGoal[0] = (this.goalPos[0] - this.pos[0]);
						dirToGoal[1] = (this.goalPos[1] - this.pos[1]);
						dirToGoal[2] = (this.goalPos[2] - this.pos[2]);
						dirToGoal = this.Normalize(dirToGoal);						

						this.localPos[0] += (1/60) * dirToGoal[0] * this.flameSpeedPerSecond;
						this.localPos[1] += (1/60) * dirToGoal[1] * this.flameSpeedPerSecond;
						this.localPos[2] += (1/60) * dirToGoal[2] * this.flameSpeedPerSecond;
					}
					else
					{
						this.goalIdx--;
						if(this.goalIdx < 0)
						{
							//explode immediately when fire reaches tnt
							var tnt = this.parent.parent;
							tnt.Explode();					

							GPU.DestroyObject(this.smoke.id);
							GPU.DestroyObject(this.id);
						}
						else													
						{
							this.SetGoalPos(this.pathPositions[this.goalIdx]);
						}
					}					

					if(this.parent == undefined)
						return;

					//need to use rope's uniform buffer so that isRope in fragment shader has access to flame pos
					GPU.device.queue.writeBuffer(this.parent.uniformBuffer, 144, new Float32Array(this.pos));
				}
											
				Render(commandPass)
				{					
					this.ParticleDraw(commandPass);
				}
			}

			class Fog extends GameObject
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);	
										
					//these triangles form a square, which is the area for the fire "texture"
					let maxDim = 0.5;
					let maxUV = 1;
					this.vertices = new Float32Array([
						 -maxDim,maxDim,0, 0,0,0, -maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
						-maxDim,-maxDim,0, 0,0,0, -maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						  maxDim,maxDim,0, 0,0,0,  maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
						 
						-maxDim,-maxDim,0, 0,0,0,  maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						 maxDim,-maxDim,0, 0,0,0, -maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						  maxDim,maxDim,0, 0,0,0, -maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
					]);
					
					this.vertexBuffer = GPU.device.createBuffer({
						label: "verticeBuffer",
						size: this.vertices.byteLength,
						usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.vertexBuffer, 0, this.vertices);

					let randStartTime = math.random()*100;
					this.timer = randStartTime;
					
					this.billboardGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(0),
						label: "flameGroup",
						entries:
						[
							{ binding: 0, resource: {buffer: this.uniformBuffer}},
							{ binding: 1, resource: {buffer: GPU.lightBuffer}},
						],
					});					
					
					//even though fire doesn't use texture bindings, the group needs to be bound since
					//group(0) interacts with the textures in group(2) in the shader
					this.SetupTextures(undefined, undefined);
					this.textureBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(2),
						label: 'customObjTextureGroup',
						entries:
						[																
							{ binding: 0, resource: this.textureObj.createView() },			
							{ binding: 1, resource: GPU.sampler },
							{ binding: 2, resource: this.normalTextureObj.createView() },
						],
					});

					//set isFog to true in the shader
					//GPU.device.queue.writeBuffer(this.uniformBuffer, 244, new Uint32Array([1]));
				}
				
				Update()
				{

				}

				Render(commandPass)
				{
					commandPass.setBindGroup(0, this.billboardGroup);
					commandPass.setBindGroup(2, this.textureBindGroup);		
					
					GPU.device.queue.writeBuffer(this.uniformBuffer, 0, new Float32Array([
						this.worldMatrix[0][0],this.worldMatrix[1][0],this.worldMatrix[2][0],this.worldMatrix[3][0],
						this.worldMatrix[0][1],this.worldMatrix[1][1],this.worldMatrix[2][1],this.worldMatrix[3][1],
						this.worldMatrix[0][2],this.worldMatrix[1][2],this.worldMatrix[2][2],this.worldMatrix[3][2],
						this.worldMatrix[0][3],this.worldMatrix[1][3],this.worldMatrix[2][3],this.worldMatrix[3][3],
					]));				
											
					GPU.device.queue.writeBuffer(this.uniformBuffer, 120, new Float32Array([this.timer]));					
					
					commandPass.setVertexBuffer(0, this.vertexBuffer);
					commandPass.draw(6,1,0,0);
				}
			}

			class DeathZone extends GameObject
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);
					this.leftX = -1 * this.localScale[0];				
					this.rightX = 1 * this.localScale[0];
					this.bottomY = -1 * this.localScale[1];
					this.topY = 1 * this.localScale[1];
					this.nearZ = -1 * this.localScale[2];	
					this.farZ = 1 * this.localScale[2];
				}

				Update()
				{

				}
				
				OnObjectStay(obj)				
				{
					var respawnPos = obj.respawnPos;					
					console.log("death zone hit cam");
					if(obj instanceof Camera)
						obj.localPos = [ respawnPos[0], respawnPos[1], respawnPos[2] ];
				}

				Render(commandPass)
				{

				}
			}

			class Boss extends CustomObj
			{
				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{					
					super(parserData, rawTexture, normalMap, pos, rot, scale);										
					this.vel = [0,0,0];															
					this.hp = 3;		

					this.flashDuration = 1.5;
					this.flashInterval = 0.1;
					this.timeFlashing = 0.0;
					
					this.spikeAttackTime = 10.0;
					this.spikeAttackTimer = 0.0;

					this.platformAttackTime = 14.0;
					this.platformAttackTimer = 0.0;
					this.timePerPlatform = 1.5;
					this.platformTimer = 0.0;					
					this.curPlatform = 0;

					this.metalAttackTimer = 0.0;
					this.metalAttackTime = 8.0;

					this.curAttack = "none";
				}

				TakeDamage(damage)
				{
					document.getElementById("creeperHurt").play();
					this.StartFlashingRed();
					this.hp -= damage;
					console.log("boss hp is now " + this.hp);
					this.curAttack = "metal";
					console.log("starting metal");
					this.StartMetal();
				}

				StartMetal()
				{
					//stop any other attacks and destroy their spikes					
					var sideSpikes = GPU.GetObjectsOfType(SideSpikes);
					var lowSpikes = GPU.GetObjectsOfType(LowSpikes);					
					for(let i = 0; i < sideSpikes.length; i++)
					{
						GPU.DestroyObject(sideSpikes.id);
					}
					for(let i = 0; i < lowSpikes.length; i++)
					{
						GPU.DestroyObject(lowSpikes.id);
					}

					this.spikeAttackTimer = 0.0;
					this.platformAttackTimer = 0.0;
					this.platformTimer = 0.0;

					var result = ParseVertices(window.cube, window.cubeMtl);
					var metal = GPU.CreateObject(2, Metal, [5, this.BottomY()-0.99, this.pos[2] + 25], [0,0,0], [25,1,25], result, window.metalTexture);
					metal.finishedMetalAttack = false;					
					metal.RestockTnt();
					//make metal fast enough for player to not get back to a crater
					metal.speed = 0.8;
				}

				StartFlashingRed()
				{
					//set flashing red to true
					this.flashOn = true;
					GPU.device.queue.writeBuffer(this.uniformBuffer, 188, new Uint32Array([1]));
					this.flashTimer = this.flashInterval;
					this.isFlashing = true;
				}				

				//how to fix flat flame?
				ShootFlame()
				{
					var scaleFactor = 0.2;
					var fireScale = [ this.scale[0] * scaleFactor, this.scale[1] * scaleFactor, this.scale[2] * scaleFactor ];
					var flame = GPU.CreateObject(2, Flame, [0,0,0], [0,0,1.6], fireScale);
				}

				//shoot two platforms that move outward each time
				ShootPlatforms()
				{					
					var pos1 = [ this.pos[0] + (this.rightX/3) + this.curPlatform * 2, this.BottomY() + 3 + 2.8 * this.curPlatform, this.pos[2] - 9 ];
					var pos2 = [ this.pos[0] - (this.rightX/3) + this.curPlatform * -2, this.BottomY() + 3 + 2.8 * this.curPlatform, this.pos[2] - 9 ];
					var result = ParseVertices(window.cube, window.cubeMtl);

					var leftPlatform = GPU.CreateObject(1, MovingPlatform, pos1, [0,0,0], [2,1,2], result, window.grassTexture);
					var rightPlatform = GPU.CreateObject(1, MovingPlatform, pos2, [0,0,0], [2,1,2], result, window.grassTexture);
					leftPlatform.vel[2] = -0.08;
					rightPlatform.vel[2] = -0.08;
				}

				SideSpikeAttack()
				{
					var result = ParseVertices(window.sideSpikes, window.sideSpikesMtl);
					var leftFarSpikes = GPU.CreateObject(2, SideSpikes, [-14,10,0], [0,math.PI,0], [2,2,2], result);
					var spikeOffset = leftFarSpikes.farZ * 2.1;
					var leftNearSpikes = GPU.CreateObject(2, SideSpikes, [-14,10,0 - spikeOffset], [0,math.PI,0], [2,2,2], result);

					leftFarSpikes.vel[0] = 0.05;
					leftNearSpikes.vel[0] = 0.05;

					var rightFarSpikes = GPU.CreateObject(2, SideSpikes, [20,10,0], [0,0,0], [2,2,2], result);
					var rightNearSpikes = GPU.CreateObject(2, SideSpikes, [20,10,0 - spikeOffset], [0,0,0], [2,2,2], result);

					rightFarSpikes.vel[0] = -0.05;
					rightNearSpikes.vel[0] = -0.05;
				}

				Update()
				{
					this.ApplySceneGraph();
					this.vel[1] += (1/60) * -0.1;					

					//attack logic
					//alternate between side spikes and moving platforms
					//use a delay after each before starting the next one

					if(this.curAttack == "spikes")
					{
						this.spikeAttackTimer += (1/60);
						if(this.spikeAttackTimer > this.spikeAttackTime)
						{
							this.spikeAttackTimer = 0.0;						
							this.curAttack = "platforms";
							this.curPlatform = 0;
						}
					}
					else if(this.curAttack == "platforms")
					{
						this.platformAttackTimer += (1/60);
						this.platformTimer += (1/60);
						if(this.platformTimer > this.timePerPlatform && this.curPlatform <= 4)
						{
							this.platformTimer = 0.0;
							this.ShootPlatforms();
							this.curPlatform++;								
						}
						if(this.platformAttackTimer > this.platformAttackTime)
						{
							this.platformAttackTimer = 0.0;	
							this.curPlatform = 0;
							this.SideSpikeAttack();
							this.curAttack = "spikes";
						}
					}
					else if(this.curAttack == "metal")
					{
						this.metalAttackTimer += (1/60);
						if(this.metalAttackTimer > this.metalAttackTime)
						{
							this.curAttack = "platforms";
							this.curPlatform = 0;
							GPU.GetObjectOfType(Metal).finishedMetalAttack = true;						
							document.getElementById("metalMove").play();
							this.metalAttackTimer = 0.0;
						}						
					}	
					// console.log("metalAttackTimer: " + this.metalAttackTimer);				
					// console.log("platformAttackTimer: " + this.platformAttackTimer);
					// console.log("platformTimer: " + this.platformTimer);
					// console.log("curPlatform: " + this.curPlatform);
					// console.log("curAttack: " + this.curAttack);

					if(this.timeFlashing > this.flashDuration)
					{
						this.isFlashing = false;
						this.flashOn = false;
						this.timeFlashing = 0.0;			
						//set flashing red to true/false
						GPU.device.queue.writeBuffer(this.uniformBuffer, 188, new Uint32Array([this.flashOn]));

						if(this.hp <= 0)
						{							
							GPU.DestroyAllObjects();
							document.getElementById("bossMusic").pause();
							document.getElementById("bossMusic").currentTime = 0.0;
							GPU.HideHearts();
							GPU.ShowWinScreen();
							GPU.gameWon = true;
						}
					}

					if(this.isFlashing)
					{
						this.timeFlashing += (1/60);
						this.flashTimer -= (1/60);
						if(this.flashTimer < 0)
						{
							this.flashTimer = this.flashInterval;
							this.flashOn = !this.flashOn;
							//set flashing red to true/false
							GPU.device.queue.writeBuffer(this.uniformBuffer, 188, new Uint32Array([this.flashOn]));
						}
					}

					this.Move();
				}

				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			class Grass extends CustomObj
			{
				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{
					super(parserData, rawTexture, normalMap, pos, rot, scale);
					//set isGrass to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 184, new Uint32Array([1]));

				}

				Update()
				{
					
				}

				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			class MovingPlatform extends CustomObj
			{
				constructor(parserData, texture, normalMap, pos, rot, scale)
				{
					super(parserData, texture, normalMap, pos, rot, scale);
				}

				Update()
				{
					this.ApplySceneGraph();
					var objHit = this.Move();
					if(objHit != undefined)					
						GPU.DestroyObject(this.id);					
				}

				Render(commandPass)
				{					
					this.IndexDraw(commandPass);
				}
			}

			class SpikePit extends CustomObj
			{
				constructor(parserData, pos, rot, scale)
				{
					super(parserData, undefined, undefined, pos, rot, scale);
				}				

				Update()
				{
					this.ApplySceneGraph();					
					this.vel[1] += (1/60) * -0.1;					
					var collision = this.Move();
					// if(collision != undefined)
					// 	console.log("spikes colliding with " + collision.id);
				}

				OnObjectStay(obj)
				{
					if(obj instanceof Camera)
					{
						document.getElementById("hitSpikes").play();
						//reset camera and take damage
						if(obj.hp > 0)
						{
							obj.localPos = [ obj.respawnPos[0], obj.respawnPos[1], obj.respawnPos[2] ];
							obj.TakeDamage(1);											
						}
					}
				}

				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			class SideSpikes extends CustomObj
			{
				constructor(parserData, pos, rot, scale)
				{
					super(parserData, undefined, undefined, pos, rot, scale);
				}				

				Update()
				{
					this.ApplySceneGraph();															
					var collision = this.Move();
					if(collision != undefined && !(collision instanceof Tnt) && !(collision instanceof Rope) && !(collision instanceof SideSpikes))
					{
						//console.log("spikes colliding with " + collision.id);
						this.OnObjectStay(collision);
						GPU.DestroyObject(this.id);
					}
				}

				OnObjectStay(obj)
				{
					if(obj instanceof Camera)
					{
						document.getElementById("hitSpikes").play();
						//reset camera and take damage				
						if(obj.hp > 0)
						{
							obj.localPos = [ obj.respawnPos[0], obj.respawnPos[1], obj.respawnPos[2] ];
							obj.TakeDamage(1);														
						}								
					}
				}

				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}
			
			class LowSpikes extends CustomObj
			{
				constructor(parserData, pos, rot, scale)
				{
					super(parserData, undefined, undefined, pos, rot, scale);
				}				

				Update()
				{
					this.ApplySceneGraph();															
					var collision = this.Move();
					if(collision != undefined && !(collision instanceof Tnt) && !(collision instanceof Rope) && !(collision instanceof SideSpikes))
					{						
						this.OnObjectStay(collision);
						GPU.DestroyObject(this.id);
					}

					//hard code to bypass tnt
					if(collision instanceof Tnt)
					{
						this.localPos[0] += this.vel[0];
						this.localPos[1] += this.vel[1];
						this.localPos[2] += this.vel[2];
					}

					//console.log("low spikes pos: " + this.pos);
				}

				OnObjectStay(obj)
				{
					if(obj instanceof Camera)
					{
						document.getElementById("hitSpikes").play();
						//reset camera and take damage						
						if(obj.hp > 0)
						{
							obj.localPos = [ obj.respawnPos[0], obj.respawnPos[1], obj.respawnPos[2] ];
							obj.TakeDamage(1);														
						}					
					}
				}

				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			class Metal extends CustomObj
			{
				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{
					super(parserData, rawTexture, normalMap, pos, rot, scale);					
					this.grass = GPU.GetObjectOfType(Grass);					

					this.isTrigger = true;
					this.finishedMetalAttack = false;
					this.startedAttack = false;
					document.getElementById("metalMove").play();
				}

				LowSpikeAttack()
				{					
					var result = ParseVertices(window.lowSpikes, window.lowSpikesMtl);
					var scaleFactor = 0.8;
					var leftFarSpikes = GPU.CreateObject(2, LowSpikes, [-14,-2,4], [0,0,0], [scaleFactor,scaleFactor,scaleFactor], result);
					var leftNearSpikes = GPU.CreateObject(2, LowSpikes, [-14,-2,-7], [0,0,0], [scaleFactor,scaleFactor,scaleFactor], result);
					var leftNearerSpikes = GPU.CreateObject(2, LowSpikes, [-14,-2,-18], [0,0,0], [scaleFactor,scaleFactor,scaleFactor], result);
					var spikeOffset = leftFarSpikes.farZ * 2.1;

					leftFarSpikes.vel[0] = 0.06;					
					leftNearSpikes.vel[0] = 0.06;					
					leftNearerSpikes.vel[0] = 0.06;
				}

				RestockTnt()
				{
					var tnts = GPU.GetObjectsOfType(Tnt);
					for(let i = 0; i < tnts.length; i++)
					{
						if(tnts[i].inQueue && !tnts[i].isCreeperTnt)													
							tnts[i].ResetTnt();						
					}					
					console.log("RESTOCKED TNT");
				}				

				Update()
				{
					this.ApplySceneGraph();					

					if(this.finishedMetalAttack)				
					{							
						this.vel[2] = -this.speed;						
					}			
					//once metal fully covers ground, clear all explode positions 
					else if(this.NearZ() < -24)
					{											
						ClearExplosions();
						if(!this.startedAttack)
						{
							this.LowSpikeAttack();
							this.startedAttack = true;
						}
						//disable isGrass, reenable later
						GPU.device.queue.writeBuffer(this.grass.uniformBuffer, 184, new Uint32Array([0]));

						this.vel = [0,0,0];
					}
					else if(this.NearZ() > -24)
					{						
						this.vel[2] = -this.speed;
					}							
					else
					{
						this.vel = [0,0,0];	
					}

					if(this.NearZ() < -90)
					{						
						//reenable isGrass to allow exploding
						GPU.device.queue.writeBuffer(this.grass.uniformBuffer, 184, new Uint32Array([1]));
						GPU.DestroyObject(this.id);
					}

					this.Move();
				}
			
				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			class Rope extends CustomObj
			{
				constructor(parserData, pos, rot, scale)
				{
					super(parserData, undefined, undefined, pos, rot, scale);
					//set isRope to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 132, new Uint32Array([1])); 					
																					
					this.burnPositions = this.GetRopeEdges();
					this.leftmostBurnPos = this.burnPositions[0];
					this.rightmostBurnPos = this.burnPositions[1];									
					
					this.camera = GPU.GetObjectOfType(Camera);
					this.litFire = 0; // 0 if not, 1 if you have lit the fire

					//if firePos isn't initialized in the shader, it will be 0,0,0 and hide the rope
					let dummyFirePos = [9999,9999,9999];
					GPU.device.queue.writeBuffer(this.uniformBuffer, 144, new Float32Array(dummyFirePos));

					this.ropeRightEnd = [this.rightmostBurnPos[0], this.rightmostBurnPos[1], this.pos[2]];
					
					//since flame hasn't been made yet, initialize flamePos in the shader so rope isn't invisible
					GPU.device.queue.writeBuffer(this.uniformBuffer, 144, new Float32Array([9000,9999,9999]));
				}								

				GetSortedPathPositions()
				{
					let positions = [];
					let reachedPath = false;					
					for(const line of window.rope1.split("\n"))
					{						
						if(line.substring(0,6) == "o Vert")					
							reachedPath = true;																			

						if(reachedPath && line[0] == "v")
						{
							let position = line.substring(2).split(' ');
							
							position[0] *= this.localScale[0];
							position[1] *= this.localScale[1];
							position[2] *= this.localScale[2];
							
							//this.pos is already accurate because of scene graph, so don't add parent positions
							position[0] += this.pos[0];
							position[1] += this.pos[1];
							position[2] += this.pos[2];														

							//position[0] *= math.cos(this.rot[2]);
							//THIS WILL BREAK LATER IF POSITION[0] IS NOT THE HALF LENGTH OF THE ROPE
							//position[1] = position[0] * math.tan(this.rot[2]);
							
							positions.push([position[0], position[1], position[2]]);							
						}
					}
					positions = this.SortByX(positions);
					console.log("rightmost pathPosition: " + positions[positions.length-1]);
					return positions;
				}
								
				GetRopeEdges()
				{
					let leftmostPos = [9999, 0, 0];
					let rightmostPos = [-9999, 0, 0];									
					for(let i = 0; i < this.vertices.length; i += GPU.vertexStride)
					{									
						if(this.vertices[i] < leftmostPos[0])
						{
							leftmostPos[0] = this.vertices[i];
							leftmostPos[1] = this.vertices[i+1];
							leftmostPos[2] = this.vertices[i+2];
						}
						if(this.vertices[i] > rightmostPos[0])
						{
							rightmostPos[0] = this.vertices[i];
							rightmostPos[1] = this.vertices[i+1];
							rightmostPos[2] = this.vertices[i+2];
						}						
					}

					leftmostPos[0] *= this.localScale[0];
					leftmostPos[1] *= this.localScale[1];
					leftmostPos[2] *= this.localScale[2];

					leftmostPos[0] += this.pos[0];
					leftmostPos[1] += this.pos[1];
					leftmostPos[2] += this.pos[2];	
					
					leftmostPos[0] *= math.cos(this.rot[2]);
					leftmostPos[1] = leftmostPos[0] * math.tan(this.rot[2]);

					rightmostPos[0] += this.pos[0];
					rightmostPos[1] += this.pos[1];
					rightmostPos[2] += this.pos[2];

					rightmostPos[0] *= this.localScale[0];
					rightmostPos[1] *= this.localScale[1];
					rightmostPos[2] *= this.localScale[2];
															
					//rightmostPos[0] *= math.cos(this.rot[2]);
					//tan(theta) = y/x, y = x * tan(theta), x = halfLength of rope
					//rightmostPos[1] = rightmostPos[0] * math.tan(this.rot[2]);
					
					// console.log("leftmost actual rope pos: " + leftmostPos);
					// console.log("rightmost actual rope pos: " + rightmostPos);
					
					this.ropeLength = this.localScale[0] * (rightmostPos[0] - leftmostPos[0]);
					return [leftmostPos, rightmostPos];
				}				

				Update()
				{
					this.ApplySceneGraph();
					
					if(this.litFire == 0)
					{
						this.distFromCamera = this.VectorDistance(this.pos, this.camera.pos);
						// Certain radius from camera
						if (this.distFromCamera <= 6)
						{
							// Player presses 'E' to light fire
							//Use optional chaining to exit if controller is null
							if(GPU.CheckKey('E') || GPU.controller?.buttons[0].pressed) 
							{
								document.getElementById("tntSizzle").play();
								this.litFire = 1;
								var spawnPos = this.rightmostBurnPos;
								spawnPos[2] = -0.1;								
								var flame = GPU.CreateObject(0, Flame, spawnPos, [0,0,0]);
								flame.StartRope(this);
							}
						}
					}										
				}

				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			class Tnt extends CustomObj
			{
				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{										
					super(parserData, rawTexture, normalMap, pos, rot, scale);
					this.flashTimer = 0.0;
					this.flashInterval = 0.15;
					this.flashOn = 1;
					this.explodeTimer = 1.5;
					this.isFlashing = false
					
					this.spawnPos = pos;									
					this.spawnScale = scale;					

					this.useCrater = true;
					this.quickDrop = false;

					//get idx this way so it works when resetting game
					this.tntIdx = GPU.GetObjectsOfType(Tnt).length;															

					//set usingTexture to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 112, new Uint32Array([1]));													
										
					//set isLaunchable to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 160, new Uint32Array([1]));
					this.vel = [0,0,0];
					this.launchVel = 40;
										
					var result = ParseVertices(window.rope1, window.rope1Mtl);
					//keep scale as 1,1,1 for now otherwise flame is messed up since it's a child
					var rope = GPU.CreateObject(2, Rope, [0,0,0], [0,0,0], [1,1,1], result);
					rope.SetParent(this);

					this.inQueue = false;
				}

				ResetTnt()
				{
					this.inQueue = false;
					//reset rope's flameWorldPos
					GPU.device.queue.writeBuffer(this.directChildren[0].uniformBuffer, 144, new Float32Array([9999,9999,9999,1]));
					//reset isFlashing
					this.isFlashing = false;
					GPU.device.queue.writeBuffer(this.uniformBuffer, 156, new Uint32Array([0]));
					//reset litFire
					this.directChildren[0].litFire = 0;
				}

				SortByTntIdx(tntList)
				{					
					for(let i = 0; i < tntList.length; i++)
					{
						for(let j = i+1; j < tntList.length; j++)
						{
							if(tntList[j].tntIdx < tntList[i].tntIdx)
							{
								var temp = tntList[j];
								tntList[j] = tntList[i];
								tntList[i] = tntList[j];	
							}
						}
					}										
					return tntList;
				}				

				Explode()
				{
					//commented to improve performance just for the expo
					// var smoke1 = GPU.CreateObject(
					// 			2, 
					// 			Smoke, 
					// 			[this.pos[0], this.pos[1]+5, this.pos[2]],
					// 			[0,0,0],
					// 			[10, 10, 10], 
					// 			0, 0, 0, 1);

					// Spawns 3 flames for now
					for(let i = 0; i < 3; i++)
					{
						let angle = math.random() * math.PI * 2;
						let r = math.sqrt(math.random()) * 4;
						
						let x = math.cos(angle) * r;
						let z = math.sin(angle) * r;

						var flame1 = GPU.CreateObject(
							0, 
							Flame, 
							[this.pos[0] + x, this.pos[1] - 6.2, this.pos[2] + z],
							[0,0,0],
							[2.5, 2.5, 2.5]);
					}
															
					if(this.useCrater)
						SetExplodePos(this.pos, this.tntIdx);

					//this could mess up explosion if the creeper tnt is recreated
					this.LaunchObjects();
					document.getElementById("boom").play();

					if(this.isCreeperTnt)
					{
						var result = ParseVertices(window.tntPack, window.tntPackMtl);
						var tnt = GPU.CreateObject(1, Tnt, this.spawnPos, [0,0,0], this.spawnScale, result, window.tntPackTexture);
						tnt.isCreeperTnt = true;
						GPU.DestroyObject(this.id);
					}				
					else
					{
						this.inQueue = true;
						this.localPos = [ this.spawnPos[0], this.spawnPos[1], this.spawnPos[2] ];
					}
				}

				LaunchObjects()
				{
					//this is after all constructors have ran, so this includes the current tnt
					let launchables = GPU.GetObjectsOfType(Tnt);
					let camera = GPU.GetObjectOfType(Camera);
					let creeper = GPU.GetObjectOfType(Boss);
					if(camera != undefined)
						launchables.push(camera);					
					if(creeper != undefined)
						launchables.push(creeper);

					for(let i = 0; i < launchables.length; i++)
					{
						var obj = launchables[i];
						if(obj == this)
							continue;
											
						var distToObj = this.VectorDistance(this.pos, obj.pos);											

						let objRight = obj.pos[0] + obj.rightX;
						let objLeft = obj.pos[0] + obj.leftX;
						
						let objTop = obj.pos[1] + obj.topY;
						let objBottom = obj.pos[1] + obj.bottomY;
						
						let objNear = obj.pos[2] + obj.nearZ;
						let objFar = obj.pos[2] + obj.farZ;

						if(obj instanceof Boss && this.isCreeperTnt)													
							obj.TakeDamage(1);

						if(distToObj > 8)
							continue;

						var dirToObj = [];
						dirToObj[0] = obj.pos[0] - this.pos[0];
						dirToObj[1] = obj.pos[1] - this.pos[1];
						dirToObj[2] = obj.pos[2] - this.pos[2];
						dirToObj = this.Normalize(dirToObj);
												
						var launchVec = [];
						launchVec[0] = (dirToObj[0] * this.launchVel) * (1/60);
						launchVec[1] = (dirToObj[1] * this.launchVel) * (1/60);
						launchVec[2] = (dirToObj[2] * this.launchVel) * (1/60);

						obj.vel = launchVec;
						//console.log("launched cam with: " + launchVec);

						if(obj instanceof Camera)						
							obj.launchVec = launchVec;			

						if(obj instanceof Tnt)
						{
							obj.StartFlashing();
							obj.explodeTimer /= 2;
						}											
					}		
				}

				Update()
				{					
					this.ApplySceneGraph();

					if(this.quickDrop && this.inQueue)
					{
						this.ResetTnt();
						this.inQueue = false;		
					}
					
					if(this.inQueue)
						return;										

					this.vel[1] += (1/60) * -0.1;
					this.Move();

					if(this.isTitleTnt && this.pos[1] < -8)
					{
						var result = ParseVertices(window.tntPack, window.tntPackMtl);
						var moveRangeX = 3;
						var moveRangeY = 6;						
						var tnt = GPU.CreateObject(1, Tnt, [ this.titlePos[0] + (math.random() * moveRangeX - moveRangeX), this.titlePos[1] + (math.random() * moveRangeY - moveRangeY), this.titlePos[2] ], [0,0,0], [1,1,1], result, window.tntPackTexture);
						tnt.isTitleTnt = true;
						tnt.titlePos = this.titlePos;
						GPU.DestroyObject(this.directChildren[0].id);
						GPU.DestroyObject(this.id);
					}

					this.flashTimer -= (1/60);
					if(this.flashTimer < 0 && this.isFlashing)
					{
						this.flashTimer = this.flashInterval;						
						(this.flashOn == 0) ? this.flashOn = 1 : this.flashOn = 0;
						//set isFlashing to true/false
						GPU.device.queue.writeBuffer(this.uniformBuffer, 156, new Uint32Array([this.flashOn]));
					}

					//reworked code to handle exploding from flame
				}

				StartFlashing()
				{													
					//set isFlashing to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 156, new Uint32Array([1]));					
					this.flashTimer = this.flashInterval;
					this.isFlashing = true;
				}
				
				Render(commandPass)
				{
					if(this.inQueue && !this.quickDrop)
						return;

					this.IndexDraw(commandPass);
				}
			}			

			class Crater extends CustomObj
			{
				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{
					super(parserData, rawTexture, normalMap, pos, rot, scale);
					
					//set usingTexture to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 112, new Uint32Array([1]));									

					//set isCrater to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 164, new Uint32Array([1]));
				}				

				Update()
				{
					this.ApplySceneGraph();				
				}

				Render(commandPass)
				{					
					this.IndexDraw(commandPass);
				}
			}

			class Fade extends GameObject
			{				
				constructor(pos, rot, scale)
				{
					//not intended to be used
					super(pos, rot, scale);

					this.mainBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(0),
						label: 'customObjMainGroup',
						entries:
						[
							{ binding: 0, resource: { buffer: this.uniformBuffer }},
							{ binding: 1, resource: { buffer: GPU.lightBuffer}},
						],
					});

					this.dummyVertices = new Float32Array([
						0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,
						0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,
						0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,
						0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,
						0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,
						0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,
					]);

					this.SetupTextures(undefined, undefined);
					this.textureBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(2),
						label: 'customObjTextureGroup',
						entries:
						[																
							{ binding: 0, resource: this.textureObj.createView() },							
							{ binding: 1, resource: GPU.sampler },
							{ binding: 2, resource: this.normalTextureObj.createView() },
						],
					});

					this.vertexBuffer = GPU.device.createBuffer({
						label: "verticeBuffer",
						size: this.dummyVertices.byteLength,
						usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.vertexBuffer, /*bufferOffset=*/0, this.dummyVertices);															


					this.fadeOpacity = 0.0;
					// set fadeVal
					GPU.device.queue.writeBuffer(this.uniformBuffer, 172, new Float32Array([this.fadeOpacity]));
					
					//set isFade to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 176, new Uint32Array([1]));
					
					this.fadeState = "none";

					this.timeInLevel = 0.0;
					this.setLights = false;
					this.level2Loaded = false;
				}				

				Update()
				{
					if(this.fadeState == "fadeOut")
						this.fadeOpacity = math.min(this.fadeOpacity + (1/60), 1);
					else if(this.fadeState == "fadeIn")
						this.fadeOpacity = math.max(this.fadeOpacity - (1/60), 0);
					
					if(this.fadeState == "fadeOut" && this.fadeOpacity > 1)		
					{											
						this.fadeState = "fadeIn";
						
						if(this.isFirstFade)
						{
							GPU.DestroyAllObjects();							
							if(this.level == 1)		
							{					
								GPU.LoadLevel1();								
							}
							else if(this.level == 2)							
							{
								document.getElementById("levelMusic").currentTime = 0.0;
								document.getElementById("levelMusic").pause();

								console.log("set ambient light");
								GPU.LoadBoss();
								this.level2Loaded = true;
								//means player died and already had lights set
								if(this.setLights)
								{
									this.LightBossLevel();
									GPU.GetObjectOfType(Camera).localPos = [4, -3, -5];
								}
							}

							this.timeInLevel = 0.0;
							this.isFirstFade = false;
							GPU.gameLoaded = true;
							GPU.ShowHearts();
							document.body.style.cursor = "none";
						}
					}											
					
					this.timeInLevel += (1/60);

					if(this.level == 2 && this.level2Loaded && this.timeInLevel > 5 && !this.setLights)
					{						
						this.LightBossLevel();						
						this.setLights = true;
					}					
				}

				LightBossLevel()
				{
					GPU.SetAmbientLight(0.75);
					var l = GPU.CreateObject(0, DirectionalLight, [5, 5.0, 0], [0,3,0]);
					document.getElementById("bossMusic").play();

					//use this later
					if(GPU.GetObjectOfType(Boss))
					{
						GPU.GetObjectOfType(Boss).lightsSet = true;
						GPU.GetObjectOfType(Boss).curAttack = "platforms";
					}
					l.color = [0.15,0.15, 0.15];
				}

				Render(commandPass)
				{
					commandPass.setBindGroup(0, this.mainBindGroup);		
					commandPass.setBindGroup(2, this.textureBindGroup);															

					GPU.device.queue.writeBuffer(this.uniformBuffer, 172, new Float32Array([this.fadeOpacity]));

					commandPass.setVertexBuffer(0, this.vertexBuffer);
					commandPass.draw(6);
				}
			}

			//basically the main class
			class WebGPU
			{
				constructor()
				{				
					this.isReady = false;					
					this.specularity = 50.0;					

					this.Visual = [];
					this.Solid = [];
					this.Trigger = [];
					this.ObjectCounter = 0;			
					this.prefab;

					this.vertexStride = 18;
					this.smokeStride = 5;
					
					this.maxPointLights = 10;
					this.maxDirLights = 10;
					this.maxSpotLights = 10;

					this.numLights = 0;
					this.numPointLights = 0;
					this.numDirLights = 0;
					this.numSpotLights = 0;
										
					this.Keys = [];
					this.explodePosInitialOffset = 192;
					this.numExplodePositions = 4;
					this.explodePos = []; //this is actually a 2d array, but don't want to set it as [[]] since that makes its length=1 on startup
					
					//2d array, with each elements being the list of objects at that pos. not used atm
					this.cellGrid = [[]];

					this.resolution = window.innerHeight / window.innerWidth;
					
					this.gameLoaded = false;
					this.gameWon = false;
					//start WebGPU rendering here
					(async () =>
					{						
						await this.SetupGPU();								
						this.TitleSlowStart();

						requestAnimationFrame(FrameUpdate);

						//remove this comment to skip title screen
						//this.StartGame();
					})();
										
				}

				TitleSlowStart()
				{					
					//need to make camera early or else bind errors
					this.camera = this.CreateObject(0, Camera, [4,-1,-5], [0,0,0.5]);			

					//basically a fade manager
					var fade = this.CreateObject(0, Fade, [0,0,0], [0,0,0]);

					var l = this.CreateObject(0, DirectionalLight, [0, 5.0, 0], [0,0,0]);
					l.color = [0.15,0.15,0.15];
					
					var result = ParseVertices(window.cube, window.cubeMtl);
					var movingGrass = GPU.CreateObject(1, MovingPlatform, [4,-3,2], [-math.PI/2,0,0], [30,1,15], result, window.grassTexture);					
					
					var tntRes = ParseVertices(window.tntPack, window.tntPackMtl);
					var leftPos = [-1, 13 + math.random() * 6 - 6, -1];
					var rightPos = [9, 13 + math.random() * 6 - 6, -1];
					var middlePos = [4, 13 + math.random() * 6 - 6, -1];

					var leftTnt = this.CreateObject(1, Tnt, leftPos, [0,0,0], [1,1,1], tntRes, window.tntPackTexture);
					var rightTnt = this.CreateObject(1, Tnt, rightPos, [0,0,0], [1,1,1], tntRes, window.tntPackTexture);
					var middleTnt = this.CreateObject(1, Tnt, middlePos, [0,0,0], [1,1,1], tntRes, window.tntPackTexture);

					leftTnt.titlePos = leftPos;
					rightTnt.titlePos = rightPos;
					middleTnt.titlePos = middlePos;

					leftTnt.isTitleTnt = true;
					rightTnt.isTitleTnt = true;
					middleTnt.isTitleTnt = true;
				}

				StartGame()
				{
					console.log("starting game...");
					this.HideTitleScreen();

					// document.getElementById("titleMusic").pause();
					// document.getElementById("titleMusic").currentTime = 0.0;
					this.fadeTitleMusic = true;					

					GPU.GetObjectOfType(Fade).fadeState = "fadeOut";
					GPU.GetObjectOfType(Fade).level = 1;
					GPU.GetObjectOfType(Fade).isFirstFade = true;
				}

				ShowHearts()
				{
					document.getElementById("heart1").style.visibility = "visible";
					document.getElementById("heart2").style.visibility = "visible";
					document.getElementById("heart3").style.visibility = "visible";
				}

				HideHearts()
				{
					document.getElementById("heart1").style.visibility = "hidden";
					document.getElementById("heart2").style.visibility = "hidden";
					document.getElementById("heart3").style.visibility = "hidden";
				}

				ShowCredits()
				{
					//means use default cursor
					document.body.style.cursor = "";

					document.getElementById("Landon").style.visibility = "visible";
					document.getElementById("Jasmine").style.visibility = "visible";
					document.getElementById("back").style.visibility = "visible";
				}

				HideCredits()
				{					
					document.getElementById("Landon").style.visibility = "hidden";
					document.getElementById("Jasmine").style.visibility = "hidden";
					document.getElementById("back").style.visibility = "hidden";
				}

				ShowTitleScreen()
				{
					document.body.style.cursor = "";

					//this also makes the menu not interactable					
					document.getElementById("title").style.visibility = "visible";	

					document.getElementById("startText").style.visibility = "visible";
					document.getElementById("start").style.visibility = "visible";

					document.getElementById("credits").style.visibility = "visible";
					document.getElementById("creditsText").style.visibility = "visible";
				}

				ShowWinScreen()
				{
					this.TitleSlowStart();
					document.body.style.cursor = "";

					document.getElementById('titleMusic').currentTime = 0
					document.getElementById('titleMusic').volume = 1

					document.getElementById("win").style.visibility = "visible";			
					document.getElementById("returnText").style.visibility = "visible";		
					document.getElementById("returnBtn").style.visibility = "visible";					
				}

				HideWinScreen()
				{
					document.getElementById("win").style.visibility = "hidden";
					document.getElementById("returnText").style.visibility = "hidden";
					document.getElementById("returnBtn").style.visibility = "hidden";
				}

				HideTitleScreen()
				{
					document.getElementById("title").style.visibility = "hidden";
					
					document.getElementById("start").style.visibility = "hidden";
					document.getElementById("startText").style.visibility = "hidden";

					document.getElementById("credits").style.visibility = "hidden";						
					document.getElementById("creditsText").style.visibility = "hidden";	
				}

				ResetGame()
				{
					this.gameLoaded = false;
					this.gameWon = false;
					this.explodePos = [];
					//reset cam pos
				}

				async LoadLevel1()
				{
					this.SetAmbientLight(0.65);

					var cam = this.GetObjectOfType(Camera);
					cam.localPos = [5, 8, 3];
					//cam.localPos = [68, 5, 68]
					//near sign
					//cam.localPos = [3.630887716868154, -2.4933333333332643, 41.90000921078645];
					//near hole
					//cam.localPos = [34.92611432861126, -8.497356481187543, 63.96737849498266];
					cam.respawnPos = cam.localPos;	
					cam.rot = [0,0,0];
					cam.hp = 3;										

					document.getElementById("levelMusic").play();
					
					var result = ParseVertices(window.cube, window.cubeMtl);
					var room1Floor = GPU.CreateObject(1, Grass, [6,-25,0], [0,0,0], [14,20,35], result, window.grassTexture);
					room1Floor.specularity = 105;

					var result = ParseVertices(window.cube, window.cubeMtl);
					var leftWall = this.CreateObject(1, CustomObj, [-10, 10, -25], [0,0,0], [2,25,50], result, window.metalTexture);
					var rightLowWall = this.CreateObject(1, CustomObj, [20, -22, 5], [0,0,0], [1,20,20], result, window.metalTexture);	
					var rightWall = this.CreateObject(1, CustomObj, [20, 18, 5], [0,0,0], [1,20,50], result, window.metalTexture);					
					var nearWall = this.CreateObject(1, CustomObj, [0, 10, -15], [0,0,0], [50,25,2], result, window.metalTexture);
					var ceiling = this.CreateObject(1, CustomObj, [0, 30, -5], [0,0,0], [100,10,100], result, window.metalTexture);

					var farWallLeft = this.CreateObject(1, CustomObj, [-20, 10, 25], [0,0,0], [22,25,2], result, window.metalTexture);
					var farWallRight = this.CreateObject(1, CustomObj, [30, 10, 25], [0,0,0], [22,25,2], result, window.metalTexture);

					var deathZone = this.CreateObject(2, DeathZone, [-15, -12, 43], [0,0,0], [20,2,20]);

					var room2FarWall = this.CreateObject(1, CustomObj, [10, 10, 35], [0,0,0], [25,25,2], result, window.metalTexture);					
					var room2Floor = this.CreateObject(1, Grass, [-36, -25, 31], [0,0,0], [22,20,25], result, window.grassTexture);		
					var room2FurtherWall = this.CreateObject(1, CustomObj, [-6, 10, 51], [0,0,0], [25,20,5], result, window.metalTexture);
					var room2CloseWall = this.CreateObject(1, CustomObj, [-39, 10, 35], [0,0,0], [2,20,20], result, window.metalTexture);

					var secondJumpFloor = this.CreateObject(1, Grass, [12, -25, 43], [0,0,0], [20,20,10], result, window.grassTexture);
					
					var result = ParseVertices(window.woodSign, window.woodSignMtl);
					var woodSign = GPU.CreateObject(1, CustomObj, [6, -5, 44], [0,2.4,0], [1,1,1], result, window.woodSignTexture, window.woodNormals);
					woodSign.specularity = 120;

					var result = ParseVertices(window.tntPack, window.tntPackMtl);
					var tnt1 = this.CreateObject(1, Tnt, [16, 0, 42], [0,0,0], [2,2,2], result, window.tntPackTexture);
					
					var result = ParseVertices(window.cube, window.cubeMtl);
					var farWallPastTnt = this.CreateObject(1, CustomObj, [10, 5, 55], [0,0,0], [55,30,2], result, window.metalTexture);
					//something is wrong with this wall
					var nearWallPastTnt = this.CreateObject(1, CustomObj, [10, 5, 36], [0,0,0], [40,30,2], result, window.metalTexture);
					var metalFloor = this.CreateObject(1, CustomObj, [55, -45, 50], [0,0,0], [25,20,20], result, window.metalTexture);

					var result = ParseVertices(window.tntPack, window.tntPackMtl);
					var tnt2 = this.CreateObject(1, Tnt, [73, 6, 47], [0,0,0], [2,2,2], result, window.tntPackTexture);
					tnt2.useCrater = false;
					tnt2.quickDrop = true;

					var result = ParseVertices(window.cube, window.cubeMtl);
					var metalCliff = this.CreateObject(1, CustomObj, [75, -30, 73], [0,0,0], [10,20,20], result, window.metalTexture);
					var nearWallBeforeCliff = this.CreateObject(1, CustomObj, [90, 5, 36], [0,0,0], [40,30,2], result, window.metalTexture);
					var cliffWallClose = this.CreateObject(1, CustomObj, [80, 5, 50], [0,0,0], [2,30,30], result, window.metalTexture);

					var farWallPastCliff = this.CreateObject(1, CustomObj, [75, -10, 95], [0,0,0], [50,30,20], result, window.metalTexture);
					var result = ParseVertices(window.tntPack, window.tntPackMtl);
					var tnt3 = this.CreateObject(1, Tnt, [73, 3, 68], [0,0,0], [2,2,2], result, window.tntPackTexture);
					tnt3.useCrater = false;
					tnt3.quickDrop = true;

					var result = ParseVertices(window.cube, window.cubeMtl);
					var floorPastGap = this.CreateObject(1, CustomObj, [40, -30, 73], [0,0,0], [16,20,16], result, window.metalTexture);
					var deathZone1 = this.CreateObject(2, DeathZone, [55, -30, 73], [0,0,0], [20,15,20]);

					var offsetX = 15;
					var offsetZ = 105;
					var leftFallWall = this.CreateObject(1, CustomObj, [-5 + offsetX, 5, -1 + offsetZ], [0,0,0], [2,200,50], result, window.metalTexture);
					var rightFallWall = this.CreateObject(1, CustomObj, [14 + offsetX, -220, -5 + offsetZ], [0,0,0], [2,200,50], result, window.metalTexture);
					var farFallWall = this.CreateObject(1, CustomObj, [-2 + offsetX, 5, -25 + offsetZ], [0,0,0], [20,200,2], result, window.metalTexture);
					var nearFallWall = this.CreateObject(1, CustomObj, [-2 + offsetX, -210, -51 + offsetZ], [0,0,0], [20,200,2], result, window.metalTexture);
				}

				async LoadBoss()
				{					
					var result = ParseVertices(window.cube, window.cubeMtl);
					var ground = GPU.CreateObject(1, Grass, [0,-25,0], [0,0,0], [50,20,100], result, window.grassTexture);
					ground.specularity = 105;

					var leftFallWall = this.CreateObject(1, CustomObj, [-10, 100, -5], [0,0,0], [2,50,50], result, window.metalTexture);
					var rightFallWall = this.CreateObject(1, CustomObj, [19, 100, -5], [0,0,0], [2,50,50], result, window.metalTexture);
					var farFallWall = this.CreateObject(1, CustomObj, [-2, 100, 10], [0,0,0], [20,50,2], result, window.metalTexture);
					var nearFallWall = this.CreateObject(1, CustomObj, [-2, 100, -10], [0,0,0], [20,50,2], result, window.metalTexture);

					var leftCeiling = this.CreateObject(1, CustomObj, [-34, 45, -5], [0,0,0], [25,10,50], result, window.metalTexture);
					var rightCeiling = this.CreateObject(1, CustomObj, [47, 45, -5], [0,0,0], [25,10,50], result, window.metalTexture);
					var farCeiling = this.CreateObject(1, CustomObj, [7, 45, 38], [0,0,0], [15,10,30], result, window.metalTexture);
					var nearCeiling = this.CreateObject(1, CustomObj, [3, 45, -40], [0,0,0], [15,10,30], result, window.metalTexture);					

					//var walkwayPos = [-15, 18, 20];					

					var cam = this.GetObjectOfType(Camera);
					cam.localPos = [4, 120, -5];
					//cam.localPos = [4, -2, -5];
					//cam.localPos = walkwayPos;
					cam.respawnPos = [ 4, -3, -5 ];
					cam.rot = [0,0,0];
					cam.hp = 3;
									
					var result = ParseVertices(window.funnyGolem, window.funnyGolemMtl);	
						
					//v coordinates for creeper texture are flipped
					var flippedVertices = result[0];
					for(let i = 7; i < flippedVertices.length; i += GPU.vertexStride)					
						flippedVertices[i] = 1 - flippedVertices[i];
					result[0] = flippedVertices;

					//you can specify less parameters than the function defines and JS will still run it
					var creeper = this.CreateObject(1, Boss, [5, 2, 13], [0,math.PI,0], [3.4,3.5,3.5], result, window.golemTexture);
					
					//make spikes a trigger so the OnObjectStay camera teleport happens after the camera moves
					var result = ParseVertices(window.spikes, window.spikesMtl);
					var leftSpikes = this.CreateObject(2, SpikePit, [-10, -4.5, 15], [0,0,0], [1.1,1.5,1.5], result);
					var rightSpikes = this.CreateObject(2, SpikePit, [20, -4.5, 15], [0,0,0], [1.1,1.5,1.5], result);

					var result = ParseVertices(window.tntPack, window.tntPackMtl);
					var tnt = this.CreateObject(1, Tnt, [5, 25, 12], [0,0,0], [2,2,2], result, window.tntPackTexture);
					tnt.isCreeperTnt = true;										
										
					var result = ParseVertices(window.tntPack, window.tntPackMtl);
					var tnt1 = GPU.CreateObject(1, Tnt, [-6, 25, 0], [0,0,0], [1,1,1], result, window.tntPackTexture);															
					var tnt2 = GPU.CreateObject(1, Tnt, [5, 25, 0], [0,0,0], [1,1,1], result, window.tntPackTexture);
					var tnt3 = GPU.CreateObject(1, Tnt, [16, 25, 0], [0,0,0], [1,1,1], result, window.tntPackTexture);

					var result = ParseVertices(window.cube, window.cubeMtl);
					var leftWall = this.CreateObject(1, CustomObj, [-20, 10, 15], [0,0,0], [2,25,50], result, window.metalTexture);
					var rightWall = this.CreateObject(1, CustomObj, [30, 10, 15], [0,0,0], [2,25,50], result, window.metalTexture);
					var farWall = this.CreateObject(1, CustomObj, [0, 10, 25], [0,0,0], [50,25,2], result, window.metalTexture);
					var nearWall = this.CreateObject(1, CustomObj, [0, 10, -25], [0,0,0], [50,25,2], result, window.metalTexture);					

					var leftWalkway = this.CreateObject(1, CustomObj, [-13, 13, 23], [0,0,0], [8,2,15], result, window.woodTexture);
					var leftWalkwayLip = this.CreateObject(1, CustomObj, [-7, 16, 23], [0,0,0], [2,3,14], result, window.woodTexture);
					var rightWalkway = this.CreateObject(1, CustomObj, [23, 13, 23], [0,0,0], [8,2,15], result, window.woodTexture);
					var rightWalkwayLip = this.CreateObject(1, CustomObj, [17, 16, 23], [0,0,0], [2,3,14], result, window.woodTexture);

					var pointLight;
					for(let i = 0; i < 5; i++)
					{															
						// pointLight = this.CreateObject(0, PointLight, [0+i*8,2, 0], [0,0,0]);
						// pointLight.color = [0.1, 0.1, 0.1];

						// var flame = this.CreateObject(0, Flame, [0,0,0], [0,0,0]);
						// flame.SetParent(pointLight);
						
						// var result = ParseVertices(window.discoBall, window.discoBallMtl);
						// var discoBall = GPU.CreateObject(1, CustomObj, [0.0, 0, 0], [0,1.5,0], [1,1,1], result);
					}

					for(let i = 0; i < 3; i++)
					{						
						var light = this.CreateObject(0, SpotLight, [-5+(i*6),-1.2,0], [0.5,0,0]);
						light.color = [i/3, 0, 0.5];
												
						// var result = ParseVertices(window.spotlight, window.spotlightMtl);
						// var spotlight = GPU.CreateObject(1, CustomObj, [i*2, 2, 1.5], [0,0,0], [0.5,0.5,0.5], result);
					}										
										
					var result = ParseVertices(window.woodSign, window.woodSignMtl);
					var woodSign = GPU.CreateObject(1, CustomObj, [5, -5, 9], [0,1.6,0], [1,1,1], result, window.woodSignTexture, window.woodNormals);
					woodSign.specularity = 120;																					
										
					let dummyPos = [9999, 9999, 9999];
					InitExplodePositions(dummyPos);													

					this.startTime = performance.now();
					this.loopsInLastSecond = 0;					
				}		

				//need to fetch the controller every frame or the input does not update
				GetControllerInput()
				{
					const controllers = navigator.getGamepads();
					if(controllers[0] != undefined)
						this.controller = controllers[0];
				}

				GetObjectOfType(type)
				{
					var object;
					for(var i in this.Visual)
					{
						if(this.Visual[i] instanceof type)						
							return this.Visual[i];
					}

					for(var i in this.Solid)
					{
						if(this.Solid[i] instanceof type)
							return this.Solid[i];
					}

					for(var i in this.Trigger)
					{
						if(this.Trigger[i] instanceof type)						
							return this.Trigger[i];
					}
					return undefined;
				}
				
				GetObjectsOfType(type)
				{
					let objects = [];
					for(var i in this.Visual)
					{
						if(this.Visual[i] instanceof type)						
							objects.push(this.Visual[i]);			
					}

					for(var i in this.Solid)
					{
						if(this.Solid[i] instanceof type)
							objects.push(this.Solid[i]);
					}

					for(var i in this.Trigger)
					{
						if(this.Trigger[i] instanceof type)						
							objects.push(this.Trigger[i]);
					}
					return objects;
				}
				
				UpdateAll()
				{					
					for(var i in this.Visual)				
						this.Visual[i].Update();
					for(var i in this.Solid)				
						this.Solid[i].Update();
					for(var i in this.Trigger)
						this.Trigger[i].Update();			
				}
				
				RenderAll(resolution)
				{										
					this.encoder = this.device.createCommandEncoder();

					let curView = this.context.getCurrentTexture().createView();
					const colorAttachment = 
					{
						view: curView,
						loadOp: "clear",
						clearValue: { r:0.2, g:0.4, b:0.6, a:1 },
						storeOp: "store"
					};					
					if(this.gameLoaded && !this.gameWon)
						colorAttachment.clearValue = {r: 0, g:0.8, b:1, a:1};
					else
						this.SetAmbientLight(0.65);
					
					if(this.fadeTitleMusic)
					{
						var titleMusic = document.getElementById("titleMusic");
						var newVol = titleMusic.volume - (1/60) * 5;
						if(newVol < ((1/60) * 2))
						{
							titleMusic.volume = 0;
							this.fadeTitleMusic = false;
						}
						else
						{
							titleMusic.volume -= (1/60) * 2;							
						}
					}

					//console.log("START MAIN PASS");
					this.mainPass = this.encoder.beginRenderPass
					({
						label: 'mainRenderPass',
						colorAttachments: [colorAttachment],
						depthStencilAttachment: {
							view: this.depthTextureView,								
							depthClearValue: 1.0,
							depthLoadOp: "clear",
							depthStoreOp: "store",

							stencilClearValue: 0,
							stencilLoadOp: 'clear',
							stencilStoreOp: 'store',
						},
					});
					this.mainPass.setPipeline(this.pipeline);
															
					//might change this order later if we want to fix the root of the smoke problem
					for(var i in this.Visual)
					{
						if(!(this.Visual[i] instanceof Fade))
							this.Visual[i].Render(this.mainPass);
					}
					for(var i in this.Solid)
						this.Solid[i].Render(this.mainPass);
					for(var i in this.Trigger)																
							this.Trigger[i].Render(this.mainPass);
					this.CheckResolution(resolution);
					
					//render fade last so transparency works
					for(var i in this.Visual)
					{
						if(this.Visual[i] instanceof Fade)
							this.Visual[i].Render(this.mainPass);
					}

					// var smokes = this.GetSmokesByDepth();
					// for(let i = 0; i < smokes.length; i++)
					// {
					// 	console.log("rendering smoke at distance: " + this.GetObjectOfType(Camera).VectorDistance(this.GetObjectOfType(Camera).pos, smokes[i].pos));
					// 	smokes[i].Render(this.mainPass);
					// }

					this.mainPass.end();
					this.mainCommandBuffer = this.encoder.finish();
					this.device.queue.submit([this.mainCommandBuffer]);
				}

				GetSmokesByDepth()
				{
					var smokes = [];
					for(var i in this.Trigger)
					{
						if(this.Trigger[i] instanceof Smoke)
							smokes.push(this.Trigger[i]);		
					}

					var camera = GPU.GetObjectOfType(Camera);

					for(let i = 0; i < smokes.length; i++)
					{
						for(let j = 0; j < smokes.length; j++)
						{
							if(camera.VectorDistance(camera.pos, smokes[i].pos) > camera.VectorDistance(camera.pos, smokes[j].pos))
							{
								var temp = smokes[i];
								smokes[i] = smokes[j];
								smokes[j] = temp;
							}
						}
					}

					console.log("sorted smokes");
					for(let i = 0; i < smokes.length; i++)
					{
						console.log(camera.VectorDistance(camera.pos, smokes[i].pos));
					}
					return smokes;
				}

				//update projection matrix in shader so the world doesn't look stretchedsda
				CheckResolution(ratio)
				{					
					var offset = 168;
					for(var i in this.Visual)				
						GPU.device.queue.writeBuffer(this.Visual[i].uniformBuffer, offset, new Float32Array([ratio]));
					for(var i in this.Solid)				
						GPU.device.queue.writeBuffer(this.Solid[i].uniformBuffer, offset, new Float32Array([ratio]));
					for(var i in this.Trigger)
						GPU.device.queue.writeBuffer(this.Trigger[i].uniformBuffer, offset, new Float32Array([ratio]));
				}
				
				CreateObject(type, prefab, pos, rot, scale, parserData, texture, normalMap, fade)
				{			
					//type 0 = visual
					//type 1 = solid
					//type 2 = trigger
					var temp;
					if(prefab == CustomObj  || prefab == Crater || prefab == Boss || prefab == MovingPlatform || prefab == Grass || prefab == Metal || prefab == Tnt)
						temp = new prefab(parserData, texture, normalMap, pos, rot, scale); //Yes this dark sorcery will work.
					else if (prefab == Rope || prefab == SpikePit || prefab == SideSpikes || prefab == LowSpikes) // || prefab == Tnt
						temp = new prefab(parserData, pos, rot, scale);
					else if (prefab == Smoke)
						temp = new prefab(pos, rot, scale, fade);
					else
						temp = new prefab(pos, rot, scale);

					var id = "ID"+this.ObjectCounter;					
					this.ObjectCounter++;
					temp.id = id;
					temp.prefab = prefab;								

					switch(type)
					{
						case 0:
							this.Visual[id] = temp;
						break;
						case 1:
							this.Solid[id] = temp;
						break;
						case 2:
							this.Trigger[id] = temp;
						break;
						default:
						break;
					}
					return temp;
				}
				
				
				DestroyObject(id)
				{
					if(id in this.Visual)
						delete this.Visual[id];
					if(id in this.Solid)
						delete this.Solid[id];
					if(id in this.Trigger)			
						delete this.Trigger[id];
				}				

				DestroyAllObjects()
				{
					for(var i in this.Visual)
					{
						//don't destroy camera or fade since they are needed for other screens
						if(this.Visual[i] instanceof Camera)
							continue;

						if(this.Visual[i] instanceof Fade)
							continue;

						delete this.Visual[i];
					}
					for(var i in this.Solid)
					{
						delete this.Solid[i];
					}
					for(var i in this.Trigger)
					{
						delete this.Trigger[i];
					}
				}

				CheckKey(k)
				{
					//console.log(Object.getOwnPropertyNames(this.Keys)); // shows all hashmap entries
					if(k in this.Keys)					
						return this.Keys[k];					
					return false;
				}
				
				KeyDown(event)
				{
					this.Keys[String.fromCharCode(event.keyCode)] = true;			
				}
				
				KeyUp(event)
				{
					this.Keys[String.fromCharCode(event.keyCode)] = false;
				}
				
				MouseClick(event)
				{
					var rect = canvas.getBoundingClientRect();
					var realX = event.clientX - rect.left;
					var realY = event.clientY - rect.top;					
					var x = -1 + 2*realX/myCanvas.width;
					var y = -1 + 2*(myCanvas.height - realY)/myCanvas.height;
					//console.log(realX+","+realY);
					//console.log("The click occurred on "+x+","+y);
				}		
				
				SetAmbientLight(val)
				{
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 0, new Float32Array([val]));
				}
								
				static keyD(event)
				{
					GPU.KeyDown(event);
				}
				static keyU(event)
				{
					GPU.KeyUp(event);
				}

				static mouseH(event)
				{
					GPU.MouseClick(event);
				}								
							
				async SetupGPU()
				{			
					this.adapter = await navigator.gpu.requestAdapter(); 
					if (!this.adapter)
					{	
						throw new Error("No appropriate GPUAdapter found.");
					}
					
					console.log("waiting for device");
					this.device = await this.adapter.requestDevice(); 
					if (!this.device)
					{
						fail('need a browser that supports WebGPU');
						return;
					}
					console.log("WebGPU device found!");
					
					this.canvas = document.querySelector('canvas');
					this.context = this.canvas.getContext('webgpu');
					this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
					this.context.configure
					(
						{
							device: this.device,
							format: this.presentationFormat,
						}
					);
					console.log("Created context with device and format");
					
					this.cellShaderModule = this.device.createShaderModule
					({
						label: "mainModule",						
						code: `	
						struct Uniforms
						{
							matrix: mat4x4<f32>, //offset 0
							rotation: vec3f, //offset 64
							
							Ka: vec3f, //offset 80
							Ks: vec3f, //offset 96
							shiny: f32, //offset 112
														
							usingTexture: u32,
							usingNormalMaps: u32,
														
							timer: f32, 
							isFlame: u32,
							isSmoke: u32,
							isRope: u32,

							flamePos: vec3f,
							isFlashing: u32,							
							isLaunchable: u32, //if this is unitialized, assume object is static

							//FIX OFFSET START
							isCrater: u32, //offset 164

							resolutionRatio: f32, //offset 168
							fadeVal: f32, //offset 172
							isFade: u32, //offset 176
							performancePercentage: f32, //offset 180
							isGrass: u32, //offset 184		
							isFlashingRed: u32, //offset 188?	
							
							//KEEP THIS AT THE END OF UNIFORMS
							explodePos: array<vec3f, 4>, //offset 196?, same as GPU.explodePosInitialOffset
						};						
						@group(0) @binding(0) var<uniform> uni: Uniforms;		

						struct VertexOutput
						{
							@builtin(position) position: vec4f,							
							@location(0) color: vec3f,	
							@location(1) texCoords: vec2f,
							@location(2) normal: vec4f,
							@location(3) Ka: vec3f,
							@location(4) Ks: vec3f,
							@location(5) shiny: f32,
							@location(6) worldSpace: vec3f,
							@location(7) vectorToCam: vec3f, //for specularity									
							@location(8) flameWorldPos: vec3f,
						};				

						struct PointLight
						{
							position: vec4f,
							color: vec4f,
						}

						struct SpotLight
						{
							position: vec4f,
							direction: vec3f,
							color: vec3f, //or intensity
						}

						struct DirLight
						{
							direction: vec3f,
							color: vec4f,
						}

						struct ComplexLightSystem
						{							
							ambient: f32, //occupies 4 bytes
							shiny: f32, //offset 4
							
							numLights: u32, //offset 8
							numPointLights: u32, //offset 12
							numSpotLights: u32, //offset 16
							numDirLights: u32, //offset 20

							pointLights: array<PointLight,10>, //offset 32, //336 = 32*10 + 16
							spotLights: array<SpotLight,10>, //offset 352
							dirLights: array<DirLight,10>, //offset 832
						}
						@group(0) @binding(1) var<uniform> lightSystem: ComplexLightSystem;						

						struct CameraInfo
						{
							translation: vec3f,
							rotation: vec3f,
						}
						@group(1) @binding(0) var<uniform> myCam: CameraInfo;

						@group(2) @binding(0) var texture: texture_2d<f32>;
						@group(2) @binding(1) var textureSampler: sampler;
						@group(2) @binding(2) var normalMap: texture_2d<f32>; //need this for normal map

						fn MoveCamera(vert: vec4f) -> vec4f
						{
							var translationM : mat4x4<f32> = mat4x4<f32>(
									vec4<f32>(1,0,0,0),
									vec4<f32>(0,1,0,0),
									vec4<f32>(0,0,1,0),
									vec4<f32>(-1.0*myCam.translation.x, -1.0*myCam.translation.y, -1.0*myCam.translation.z, 1)
								);									
							
							//rotate world opposite of camera
							var c : vec3f = cos(-1.0*myCam.rotation);
							var s : vec3f = sin(-1.0*myCam.rotation);
							var rotM : mat4x4<f32> = mat4x4<f32>(
								vec4<f32>(c.y, 0.0, -s.y, 0.0),
								vec4<f32>(0.0, 1.0, 0.0, 0.0),
								vec4<f32>(s.y, 0.0, c.y, 0.0),
								vec4<f32>(0.0, 0.0, 0.0, 1.0),
							);

							//make everything orbit around camera
							return rotM * translationM * vert;
						}

						fn PerspectiveProjection(vert: vec4f) -> vec4f
						{
							var n: f32 = 0.001;
							var r: f32 = 0.001;
							var t: f32 = 0.001;
							var f: f32 = 5000.0;

							//column-major
							var perspectiveM : mat4x4<f32> = mat4x4<f32>(
									vec4<f32>(uni.resolutionRatio * n/r,0,0,0), //uni.resolutionRatio *
									vec4<f32>(0, n/t, 0,0),
									vec4<f32>(0,0,(f+n)/(f-n),1),
									vec4<f32>(0,0,2*f*n/(f-n),1),
								);

							return perspectiveM * vert;
						}

						fn reflectVec(I: vec3<f32>, N: vec3<f32>) -> vec3<f32>
						{
							return I - 2.0 * dot(N, I) * N;	
						}

						//blinn phong half vector
						fn halfVec(L: vec3<f32>, V: vec3<f32>) -> vec3<f32>
						{
							return normalize(L + V);
						}

						//Rotate the object off the euler angle rotations.
						fn rotate(vert: vec4f) -> vec4f
						{
								var c : vec3f = cos(uni.rotation);
								var s : vec3f = sin(uni.rotation);

								var rotX : mat4x4<f32> = mat4x4<f32>(
								vec4<f32>( 1.0, 0.0, 0.0, 0.0 ),
								vec4<f32>( 0.0, c.x, -s.x, 0.0 ),
								vec4<f32>( 0.0, s.x,  c.x, 0.0 ),
								vec4<f32>( 0.0, 0.0, 0.0, 1.0 ));
						
								var rotY : mat4x4<f32> = mat4x4<f32>(
								vec4<f32>( c.y, 0.0, -s.y, 0.0 ),
								vec4<f32>( 0.0, 1.0,  0.0, 0.0 ),
								vec4<f32>( s.y, 0.0,  c.y, 0.0 ),
								vec4<f32>( 0.0, 0.0, 0.0, 1.0 ));								

								var rotZ : mat4x4<f32> = mat4x4<f32>(
								vec4<f32>( c.z, -s.z, 0.0, 0.0 ),
								vec4<f32>( s.z, c.z,  0.0, 0.0 ),
								vec4<f32>( 0.0, 0.0,  1.0, 0.0 ),
								vec4<f32>( 0.0, 0.0, 0.0, 1.0 ));
								
								return rotZ * rotY * rotX * vec4f(vert);
								//return rotY*vec4f(vert);
						}		

						//FIRE STUFF

						fn noise(pos: vec3<f32>) -> f32
						{
							var cell_coord = floor(pos);
							var hash_seed = dot(cell_coord, vec3<f32>(1.0, 57.0, 21.0)) + vec4<f32>(0.0, 27.0, 21.0, 78.0);
							var interp = cos((pos - cell_coord) * acos(-1.0)) * -0.5 + 0.5;
							hash_seed  = mix(sin(cos(hash_seed)*hash_seed), sin(cos(1+hash_seed)*(1+hash_seed)), interp.x);
							var blended_xy = mix(hash_seed.xz, hash_seed.yw, interp.y);
							hash_seed.x = blended_xy.x;
							hash_seed.y = blended_xy.y;
							return mix(hash_seed.x, hash_seed.y, interp.z);
						}

						fn sphere(pos: vec3<f32>, spr: vec4<f32>) -> f32
						{
							return length(spr.xyz - pos) - spr.w;
						}
								
						fn flame(pos: vec3<f32>) -> f32
						{							
							var iTime = uni.timer;
							var d = sphere(pos*vec3<f32>(1.0, 0.5, 1.0), vec4<f32>(0.0, -1.0, 0.0, 1.0));
							return d + (noise(pos + vec3<f32>(0.0, iTime * 2.0, 0.0)) + noise(pos * 3.0) * 0.5) * 0.25 * (pos.y);
						}

						fn scene(pos: vec3<f32>) -> f32
						{
							return min(100.0 - length(pos), abs(flame(pos)));
						}

						fn raymarch(ogPos: vec3<f32>, dir: vec3<f32>) -> vec4<f32>
						{
							var d = 0.0;
							var glow = 0.0;
							var eps = 0.02;	
							var pos = ogPos;					
							var glowed = 0u;
							
							for(var i = 0; i < 40; i++)
							{
								d = scene(pos) + eps;								
								pos = pos + d * dir;
								if(d > eps)
								{
									if(flame(pos) < 0.0)
									{
										glowed = 1u;
									}
																	
									if(glowed == 1u)
									{
										glow = f32(i) / 64.0;
									}
								}
							}
							return vec4<f32>(pos, glow);
						}		
								
						fn smoke_density(pos: vec3<f32>) -> f32 
						{
							let t = uni.timer * 0.3;

							let base = 1.0 - smoothstep(0.0, 2, length(pos.xz));

							let n = noise(pos * 1.0 + vec3<f32>(0.0, t, 0.0));

							var d = base * n;

							d *= smoothstep(-1.0, 0.0, pos.y);
							d *= (2.5 - clamp(pos.y, 0.0, 2));

							return max(d, 0.0);
						}
						
						fn raymarch_smoke(org : vec3<f32>, dir : vec3<f32>) -> vec4<f32>
						{
							let steps = 64;								
							//use adjustedSteps for dynamic performance changing						
							//var adjustedSteps: i32 = i32(uni.performancePercentage * f32(steps));							
							//var adjustedSteps = steps;
							let stepSize = 0.15; // / (uni.performancePercentage);							

							var pos = org;
							var alpha = 0.0;
							var color = vec3<f32>(0.0);							

							for (var i = 0; i < steps; i = i + 1)
							{
								pos = pos + dir * stepSize;
								let density = smoke_density(pos);

								if (density <= 0.0001) 
								{ 
									continue; 
								}

								let a = density * 0.15;
								alpha = alpha + (1.0 - alpha) * a;

								color = color + vec3<f32>(0.6) * a;

								if (alpha > 0.98) 
								{ 
									break; 
								}
							}

							return vec4<f32>(color, alpha);
						}

						
						//the parameters correspond to the vertexBufferLayout object						
						@vertex						
						fn vertexMain(@builtin(vertex_index) index: u32, @location(0) pos: vec3f, @location(1) col: vec3f, @location(2) texCoords: vec2f, @location(3) normal: vec3f, @location(4) Ka: vec3f, @location(5) Ks: vec3f, @location(6) shiny: f32) -> VertexOutput
						{
							var vOutput: VertexOutput;
							let worldPos4: vec4<f32> = uni.matrix * vec4f(pos, 1.0);
							vOutput.worldSpace = worldPos4.xyz;
							vOutput.position = PerspectiveProjection(MoveCamera(worldPos4));

							//may need an array of flame positions later
							vOutput.flameWorldPos = uni.flamePos;

							vOutput.normal = rotate(vec4f(normal, 0.0));
							vOutput.vectorToCam = myCam.translation - vOutput.worldSpace.xyz;

							vOutput.Ka = Ka;
							vOutput.Ks = Ks;
							vOutput.shiny = shiny;
														
							vOutput.color = col;
							vOutput.texCoords = texCoords;

							if(uni.isFlame == 1u || uni.isSmoke == 1u)
							{								
								//offset fire texture coords
								vOutput.texCoords = vOutput.texCoords * 0.5 + 0.5;
							}							

							if(uni.isFade == 1u)
							{
								var pos = array<vec2<f32>, 6>(
									vec2<f32>(-1.0, 1.0),
									vec2<f32>( 1.0, -1.0),
									vec2<f32>( 1.0,  1.0),

									vec2<f32>(-1.0,  1.0),
									vec2<f32>(-1.0, -1.0),
									vec2<f32>(1.0, -1.0),
								);
								vOutput.position = vec4<f32>(pos[index], 0.0, 1.0);
							}

							return vOutput;
						}
												
						@fragment
						fn fragmentMain(fsInput: VertexOutput) -> @location(0) vec4f
						{
							//get the early returns out of the way first for better performance	
							if(uni.isFade == 1u)
							{
								return vec4f(0,0,0,uni.fadeVal);							
							}

							if(uni.isFlashingRed == 1u)
							{
								return vec4f(1,0,0,1);
							}

							if(uni.isFlame == 1u)
							{
								var v = -1.0 + 2.0 * fsInput.texCoords.xy / 1.0;
								var org = vec3<f32>(0, -2, 4);
								var dir = normalize(vec3<f32>(v.x * 1.6, -v.y, -1.5));

								var pos = raymarch(org, dir);
								var glow = pos.w;

								var col = mix(vec4<f32>(1, 0.5, 0.1, 1), vec4<f32>(0.1, 0.5, 1, 1), pos.y * 0.02 + 0.4);
								var fragColor = mix(vec4<f32>(0), col, pow(glow*2, 4));
								fragColor.w = 1.0;
								if(glow < 0.05)
								{
									discard;
								}
								else if(fragColor.x < 0.9 && fragColor.y < 0.9 && fragColor.z < 0.9)
								{
									fragColor.x = 0.9;
								}
								return fragColor;
							}					
								
							if(uni.isSmoke == 1u)
							{
								var v = -1.0 + 2.0 * fsInput.texCoords.xy;
								var org = vec3<f32>(0.0, -2.0, 4.0);
								//smoke explodes to size of screen. how to widen it a ton?
								var dir = normalize(vec3<f32>(v.x * 1.6, -v.y, -1));

								let sm = raymarch_smoke(org, dir);

								if (sm.a < 0.01) {
									discard;
								}

								return sm;
															
								//return vec4f(1.0, 1.0, 1.0, 0.5);		
							}
							
							if(uni.isRope == 1u)
							{
								//flameWorldPos moves left. discard pixels as flameWorldPos reaches them
								if(fsInput.worldSpace.x + 0.05 > fsInput.flameWorldPos.x)
								{
									discard;
								}
							}
							
							if(uni.isFlashing == 1u)
							{
								return vec4f(1);
							}						

							var AMBIENT_TOTAL = fsInput.color * lightSystem.ambient;		
							var newNormal: vec3f = fsInput.normal.xyz;
							var normalizedNormal: vec3f = normalize(fsInput.normal.xyz);

							let dx: vec3f = normalize(dpdx(fsInput.worldSpace));
							let bitangent: vec3f = normalize(cross(normalizedNormal, dx));
							let tangent: vec3f = normalize(cross(bitangent, normalizedNormal));							

							//read tangent from file or manually calculate tangent?
							let TBN = mat3x3<f32>(tangent, bitangent, normalizedNormal); //basically a lookat matrix from surface, use vertice normal
							
							let normalMapColor: vec3f = textureSample(normalMap, textureSampler, fsInput.texCoords).rgb;
							let normalTangent: vec3f = normalMapColor * 2.0 - 1.0;
							var normalWS = normalize(TBN * normalTangent); //old texture example code

							//there's weird errors when using fsInput.worldSpace or textureSample near dpdx, so I'm setting this variable early
							let textureValues = textureSample(texture, textureSampler, fsInput.texCoords);														
																																																						
							for(var i = 0u; i < 4u; i++)
							{							
								// hard coded explosion radius for now, might customize later							
								if(distance(fsInput.worldSpace, uni.explodePos[i]) < 7.92 && (uni.isGrass == 1u || uni.isCrater == 1u || uni.isRope == 1u))
								{
									discard;
								}
							}								

							if(uni.isCrater == 1u && fsInput.worldSpace.y < -5)
							{
								return textureValues;
							}
							//discard top part of crater
							else if(uni.isCrater == 1u)
							{
								discard;
							}										

							if(uni.usingNormalMaps == 1u)
							{
								newNormal = normalWS;
							}															
						
							var lightPower: vec3f = vec3<f32>(0,0,0); //summation of all light power
							var specPower: vec3<f32>; //summation of all specularity light power
							var dirLight: vec3<f32>; //summation of all directional light power							

							lightPower = vec3(0,0,0);
							specPower = vec3(0,0,0);
							dirLight = vec3(0,0,0);

							var LPos: vec3<f32>; //normalized vector to the light
							var LPosSafe: vec3<f32>; //make sure lRaw is not 0
							var IL: f32; //illumination of light

							//for specularity
							var reflection: vec3<f32>;
							var halfVector: vec3<f32>;
							
							//for spotlight
							var focus: f32;
							var direction: vec3<f32> = vec3<f32>(1,-1,1);							

							for(var i = 0u; i < min(lightSystem.numPointLights, 10u); i++)
							{																			
								var light: PointLight; //specific light instance									
								light = lightSystem.pointLights[i];									

								//normalizing in vertex shader results in squarish edges
								LPos = normalize(light.position.xyz - fsInput.worldSpace).xyz;
								LPosSafe = LPos;

								// L = select(vec3<f32>(0,0,0,0),lRaw,all(lRaw != vec3<f32>(0.0)));
																
								//dividing by length gives light falloff, light intensity variable is the coefficient here
								IL = 5 * max( dot(normalize(newNormal.xyz),LPosSafe), 0.0 ) / (1 + length(light.position.xyz - fsInput.worldSpace));
								lightPower += light.color.xyz*IL;
								
								if(IL > 0.0)
								{									
									reflection = reflectVec(-normalize(light.position.xyz - fsInput.worldSpace), normalize(newNormal).xyz);
									halfVector = halfVec(-LPosSafe, normalize(fsInput.vectorToCam).xyz);
									specPower += pow(
														max( dot(normalize(reflection), normalize(fsInput.vectorToCam) ), 0),
														uni.shiny
													) * light.color.xyz;		
								}
							}							

							for(var i = 0u; i < min(lightSystem.numSpotLights, 10u); i++)
							{																											
								var light: SpotLight; //specific light instance								
								light = lightSystem.spotLights[i];																						

								focus = dot(normalize(light.position.xyz - fsInput.worldSpace), normalize(-1*light.direction));
								if(focus >= 0.88)
								{									
									lightPower += max(
														dot(	normalize(newNormal).xyz, 
																normalize(light.position.xyz - fsInput.worldSpace).xyz), 
														0.0
														) * light.color.xyz;
								}
							}
																							
							for(var i = 0u; i < min(lightSystem.numDirLights, 10u); i++)
							{																																				
								var light: DirLight;																	
								light = lightSystem.dirLights[i];													
								
								IL = max( dot(normalize(newNormal.xyz), normalize(light.direction)), 0.0 );
								dirLight += IL * light.color.xyz;
							}
								
							//isSmoke got moved to the top of the fragment shader to return earlier for slightly better performance							
							
							var textureUse : f32;
							textureUse = f32(uni.usingTexture);
							if(uni.usingTexture == 1u)
							{
								return vec4f(vec4f(uni.Ka.x, uni.Ka.y, uni.Ka.z, 1) * textureValues * lightSystem.ambient + vec4f(dirLight + lightPower + specPower, 1));
							}
							else
							{
								return vec4f(vec4f(uni.Ka.x, uni.Ka.y, uni.Ka.z, 1) * vec4(fsInput.color, 1) * lightSystem.ambient + vec4f(dirLight + lightPower + specPower, 1));
							}
						}`
					});
					console.log("Created simple shader");										
					
					//BUFFER VARS
					
					this.lightBuffer = GPU.device.createBuffer({
						label: 'lightBuffer',
						size: 1152,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					});
					this.dummyUniformBuffer = GPU.device.createBuffer({
						label: 'dummyUniform',
						size: 240,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					});										
					this.uniformBuffer = GPU.device.createBuffer({
						label: 'dummyUniform',
						size: 240,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					});
					//linear vs point sample distance for textures
					this.sampler = this.device.createSampler({
						addressModeU: 'repeat',
						addressMoveV: 'mirror-repeat',
						minFilter: 'nearest',
						maxFilter: 'linear',
					});

					//LAYOUT VARS

					this.vertexBufferLayout =					
					{
						label: 'mainVertexBufferLayout',
						arrayStride: GPU.vertexStride*4,
						attributes:
						[					
							//position	
							{
								format: "float32x3", 
								offset:0, 
								shaderLocation:0,
							},
							//color
							{
								format: "float32x3", 
								offset:3*4, 
								shaderLocation:1,
							},
							//texture uv coords
							{
								format:"float32x2", 
								offset:6*4, 
								shaderLocation:2,
							},
							//normal
							{
								format:"float32x3",
								offset:8*4,
								shaderLocation:3,
							},
							//Ka
							{
								format:"float32x3",
								offset:11*4,
								shaderLocation:4,
							},
							//Ks
							{
								format:"float32x3",
								offset:14*4,
								shaderLocation:5,
							},
							//Ns
							{
								format:"float32",
								offset:17*4,
								shaderLocation:6,
							},
						],
					};					
								
					this.mainGroupLayout = this.device.createBindGroupLayout
					({
						label: 'mainGroupLayout',
						entries:
						[
							{
								binding: 0, //Uniform
								visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
								buffer: { type: 'uniform', }, 
							},
							{
								binding: 1, //ComplexLightSystem
								visibility: GPUShaderStage.FRAGMENT,
								buffer: { type: 'uniform', }
							},							
						],
					});					

					this.cameraGroupLayout = this.device.createBindGroupLayout
					({
						label: 'cameraGroupLayout',
						entries:
						[
							{
								binding: 0,
								visibility: GPUShaderStage.VERTEX,
								buffer: {type: 'uniform', },
							}
						]
					})

					this.textureGroupLayout = this.device.createBindGroupLayout
					({
						label: "textureGroupLayout",
						entries:
						[
							{
								binding: 0, //texture_2d
								visibility: GPUShaderStage.FRAGMENT,
								texture: {}, //sampleType: "float"
							},
							{
								binding: 1, //texture sampler
								visibility: GPUShaderStage.FRAGMENT,
								sampler: {}, //type: "filtering"
							},		
							{
								binding: 2, //texture sampler
								visibility: GPUShaderStage.FRAGMENT,
								texture: {}, //type: "filtering"
							},
						],
					});

					this.mainPipelineLayout = this.device.createPipelineLayout
					({
						label: 'mainPipelineLayout',
						bindGroupLayouts: [ this.mainGroupLayout, this.cameraGroupLayout, this.textureGroupLayout ]
					});					

					//PIPELINE VARS					
					
					this.pipeline = this.device.createRenderPipeline
					({
						label: "Main pipeline",
						layout: this.mainPipelineLayout, //layout: "auto",
						vertex: 
						{
							module: this.cellShaderModule,
							entryPoint: "vertexMain",
							buffers: [this.vertexBufferLayout],
						},
						fragment:
						{
							module: this.cellShaderModule,
							entryPoint: "fragmentMain",
							targets: [{
								format: this.presentationFormat,
								blend: {
									color: {
										srcFactor: "src-alpha",
										dstFactor: "one-minus-src-alpha",
										operation: "add",
									},
									alpha: {
									  srcFactor: "one",
									  dstFactor: "one-minus-src-alpha",
									  operation: "add",
									},
								},
								//writeMask: GPUColorWrite.ALL,
								}]
						},
						primitive:
						{							
							topology: "triangle-list",
							cullMode: "none",							
							// topology: "triangle-strip",
							// stripIndexFormat: "uint16",
						},						
						depthStencil: {
							format: "depth24plus-stencil8",
							depthWriteEnabled: true,
							depthCompare: "less-equal",
						},						
					});
					console.log("Created pipeline");					
										
					this.depthTexture = this.device.createTexture({
						label: 'depthTexture',
						size: [this.canvas.width, this.canvas.height],
						format: "depth24plus-stencil8",
						usage: GPUTextureUsage.RENDER_ATTACHMENT,
					});
					this.depthTextureView = this.depthTexture.createView();

					this.ShowTitleScreen();					
				}
			}							
			
			//do title screen stuff here, then make GPU with event listener			
			//try delaying slow start and rendering black in WebGPU until a button is clicked?
			var canvas = document.getElementById("myCanvas");
			
			canvas.addEventListener("click", WebGPU.mouseH);
			GPU = new WebGPU();			

			window.onkeydown = WebGPU.keyD;
			window.onkeyup = WebGPU.keyU;	
			window.addEventListener("gamepadconnected", (e) =>
			{
				console.log("Controller connected: " + e.gamepad);
			});

			window.addEventListener("resize", () =>
			{
				console.log("Window resized!");
				var ratio =  window.innerHeight / window.innerWidth;
				GPU.resolution = ratio;
			});

			window.addEventListener("click", () =>
			{				
				var titleMusic = document.getElementById("titleMusic");
				if(titleMusic.currentTime == 0.0 && !startedMusic)
				{
					titleMusic.play();
					startedMusic = true;
				}
			});
		</SCRIPT>
	</HEAD>
</HTML>