<HTML>
	<HEAD>
		<BODY style="
			margin: 0;
			padding: 0;
			overflow: hidden; /* prevents scrollbars */
			height: 100%;
			width: 100%;
		"> 
			<!-- this will have issues if window is resized -->
			<canvas id="myCanvas" style="display: block; width: 100%; height: 100%;" width="1500" height="750"></canvas>
			<audio id="boom" src="Audio/VineBoom.mp3"></audio>
		</BODY>
	
	
		<script src="./BasicGameObjects.js"></script>
		<script src="./Models.js"></script>
		<script src="./Textures.js"></script>
		<script src="./Parsing.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

		<!-- All classes, and WebGPU will be defined (or imported) here -->
		 <!-- WRITE MAT4 MATRICES DIRECTLY INTO BUFFER, DON'T REORDER -->
		<SCRIPT>

			/*
			HOW TO DO SPHERE COLLISION?
			In crater class, check distance from center to Camera.
			If within range + radius, disable collision, else enable collision.
			*/
			
			function FrameUpdate()
			{				
				GPU.GetControllerInput();
				GPU.UpdateAll();
				GPU.RenderAll(GPU.resolution);
				averageTime = (performance.now() - GPU.startTime) / GPU.loops;
				GPU.loops++;
				// console.log("average loop time: " + averageTime + "ms");
				// console.log("percentage of full speed: " + ((averageTime*60)/1000));
				requestAnimationFrame(FrameUpdate);
			}			

			//making this a global function so it can be called after all objects have been made
			function InitExplodePositions(dummyPos)
			{
				dummyPos.push(1);

				for(let i = 0; i < 3; i++)
				{
					console.log("set all explode positions for current objects to " + dummyPos);
					let initialOffset = 176;
					for(var j in GPU.Visual)
						GPU.device.queue.writeBuffer(GPU.Visual[j].uniformBuffer, initialOffset + (16 * i), new Float32Array(dummyPos));
					for(var j in GPU.Solid)
						GPU.device.queue.writeBuffer(GPU.Solid[j].uniformBuffer, initialOffset + (16 * i), new Float32Array(dummyPos));
					for(var j in GPU.Trigger)
						GPU.device.queue.writeBuffer(GPU.Trigger[j].uniformBuffer, initialOffset + (16 * i), new Float32Array(dummyPos));
				}
			}			
							
			//when a crater is made, initialize its explodePositions to the current GPU explodePositions
			//then write the crater's new explode pos to all objects
			function SetExplodePos(pos, idx)
			{					
				pos.push(1); //make pos a vec4f to ensure it is 16 bytes long				
				var result = ParseVertices(window.sphere, window.sphereMtl);
				var sphere = GPU.CreateObject(0, Crater, pos, [0,0,0], [8,8,8], result, window.grassTexture, window.grassNormals);
				
				//to set AND retrieve current explodePositions as craters are made, keep array of explodePositions in WebGPU class
				GPU.explodePos[idx] = pos;
				console.log("set explodePos[" + idx + "] to " + pos);
				
				//idx represents the tnt number it is, like 0th tnt or 1st tnt for explodePos[0] or explodePos[1] in shader
				let initialOffset = 176;
				for(var i in GPU.Visual)
					GPU.device.queue.writeBuffer(GPU.Visual[i].uniformBuffer, initialOffset + (16 * idx), new Float32Array(pos));
				for(var i in GPU.Solid)
					GPU.device.queue.writeBuffer(GPU.Solid[i].uniformBuffer, initialOffset + (16 * idx), new Float32Array(pos));
				for(var i in GPU.Trigger)
					GPU.device.queue.writeBuffer(GPU.Trigger[i].uniformBuffer, initialOffset + (16 * idx), new Float32Array(pos));
			}			

			class PointLight extends Light
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);		

					this.pointLightIndex = GPU.numPointLights;
					GPU.numPointLights++;								
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 12, new Uint32Array([GPU.numPointLights]));
					
					this.moveTime = 2.0;
					this.moveTimer = 2.0;
					this.curDir = -1;
					this.moveSpeed = 0.1;					
				}
				
				Update() 
				{
					this.ApplySceneGraph();

					if(this.curDir == -1)
						this.localPos[0] -= this.moveSpeed;
					else if(this.curDir == 1)
						this.localPos[0] += this.moveSpeed;

					this.moveTimer -= (1.0/60.0);

					if(this.moveTimer < 0)
					{
						this.curDir *= -1;
						this.moveTimer = this.moveTime;
					}					
				}

				Render(pass)
				{					
					pass.setBindGroup(0, this.pLightGroup);
										
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 4, new Float32Array([this.specularity]));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (32 + 32*this.pointLightIndex), new Float32Array(this.pos));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (48 + 32*this.pointLightIndex), new Float32Array(this.color));

					GPU.device.queue.writeBuffer(this.uniformBuffer, 0, new Float32Array([
							this.worldMatrix[0][0],this.worldMatrix[1][0],this.worldMatrix[2][0],this.worldMatrix[3][0],
							this.worldMatrix[0][1],this.worldMatrix[1][1],this.worldMatrix[2][1],this.worldMatrix[3][1],
							this.worldMatrix[0][2],this.worldMatrix[1][2],this.worldMatrix[2][2],this.worldMatrix[3][2],
							this.worldMatrix[0][3],this.worldMatrix[1][3],this.worldMatrix[2][3],this.worldMatrix[3][3],
						]));					
						GPU.device.queue.writeBuffer(this.uniformBuffer, 64, new Float32Array(this.rot));
				}
			}

			class SpotLight extends Light
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);
					this.spotLightIndex = GPU.numSpotLights;
					GPU.numSpotLights++;
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 16, new Uint32Array([GPU.numSpotLights]));
					this.moveSpeed = 0.01;
				}
				
				Update()
				{
					this.ApplySceneGraph();
					this.transform.doRotations(this.localRot);
					this.localRot[1] += this.moveSpeed;			
				}				

				Render(commandPass)
				{
					commandPass.setBindGroup(0, this.pLightGroup);
									
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 4, new Float32Array([this.specularity]));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (352 + 48*this.spotLightIndex), new Float32Array(this.pos));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (368 + 48*this.spotLightIndex), new Float32Array(this.transform.forward));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (384 + 48*this.spotLightIndex), new Float32Array(this.color));															
				}
			}

			class DirectionalLight extends Light
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);

					this.dirLightIndex = GPU.numDirLights;
					GPU.numDirLights++;														
					GPU.device.queue.writeBuffer(GPU.lightBuffer, 20, new Uint32Array([GPU.numDirLights]));

					this.moveTime = 2.0;
					this.moveTimer = 2.0;
					this.curDir = -1;
					this.moveSpeed = 0.01;
				}
				
				Update()
				{
					if(this.curDir == -1)
						this.localRot[1] -= this.moveSpeed;
					else if(this.curDir == 1)
						this.localRot[1] += this.moveSpeed;

					this.moveTimer -= (1.0/60.0);

					if(this.moveTimer < 0)
					{
						this.curDir *= -1;
						this.moveTimer = this.moveTime;
					}
					this.transform.doRotations(this.localRot);
				}

				Render(commandPass)
				{														
					commandPass.setBindGroup(0, this.pLightGroup);										

					//GPU.device.queue.writeBuffer(GPU.lightBuffer, 4, new Float32Array([this.specularity]));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (832 + 32*this.dirLightIndex), new Float32Array(this.transform.forward));
					GPU.device.queue.writeBuffer(GPU.lightBuffer, (848 + 32*this.dirLightIndex), new Float32Array([this.color[0], this.color[1], this.color[2], 0.0]));					
				}
			}

			class CustomObj extends GameObject
			{
				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{
					super(pos, rot, scale);

					if(parserData != undefined)
					{						
						this.vertices = parserData[0];
						this.indexes = parserData[1];

						//will probably put this in a uniform later
						this.Ka = parserData[2];
						this.Ks = parserData[3];
						this.specularity = parserData[4];						
					}
										
					this.vertexBuffer = GPU.device.createBuffer({
						label: "verticeBuffer",
						size: this.vertices.byteLength,
						usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.vertexBuffer, /*bufferOffset=*/0, this.vertices);
					
					this.indexBuffer = GPU.device.createBuffer({
						label: "indexBuffer",
						size: this.indexes.byteLength,
						usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.indexBuffer, /*bufferOffset=*/0, this.indexes);

					this.specularity = 1;											
					
					this.mainBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(0),
						label: 'customObjMainGroup',
						entries:
						[
							{ binding: 0, resource: { buffer: this.uniformBuffer }},
							{ binding: 1, resource: { buffer: GPU.lightBuffer}},
						],
					});							

					this.SetupTextures(rawTexture, normalMap);
					this.textureBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(2),
						label: 'customObjTextureGroup',
						entries:
						[																
							{ binding: 0, resource: this.textureObj.createView() },							
							{ binding: 1, resource: GPU.sampler },
							{ binding: 2, resource: this.normalTextureObj.createView() },
						],
					});
					this.timer = 0.0;					
				}

				Update()
				{	
					this.ApplySceneGraph();					
				}				

				Render(pass)
				{
					this.IndexDraw(pass);
				}
			}

			class Camera extends GameObject
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);					

					this.camBuff = GPU.device.createBuffer({
						label: 'camBuffer',
						size: 32,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					});

					this.camGroup = GPU.device.createBindGroup({
						layout: GPU.pipeline.getBindGroupLayout(1),
						label: 'camera',
						entries: [
							{ binding: 0, resource: {buffer: this.camBuff}},
						],
					});

					
					this.moveSpeed = 0.06;
					this.strafeSpeed = 0.06;
					this.rotSpeed = 0.04;
					this.elevateSpeed = 0.06;

					//set isLaunchable to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 160, new Uint32Array([1]));
					this.vel = [0,0,0];					

					this.stickDeadzone = 0.05;
				}
				
				LeftStickX()
				{
					if(GPU.controller == undefined)	
						return 0.0;
					return GPU.controller.axes[0];							
				}

				LeftStickY()
				{
					if(GPU.controller == undefined)	
						return 0.0;
					return GPU.controller.axes[1] * -1;
				}

				RightStickX()
				{					
					if(GPU.controller == undefined)	
						return 0.0;
					return GPU.controller.axes[2];
				}

				RightStickY()
				{
					if(GPU.controller == undefined)	
						return 0.0;
					return GPU.controller.axes[3] * -1;
				}
				
				LeftTriggerHeld()
				{
					if(GPU.controller == undefined)	
						return false;
					return GPU.controller.buttons[6].pressed;
				}

				RightTriggerHeld()
				{
					if(GPU.controller == undefined)	
						return false;
					return GPU.controller.buttons[7].pressed;
				}

				LeftDpadHeld()
				{
					if(GPU.controller == undefined)	
						return false;
					return GPU.controller.buttons[14].pressed;
				}

				RightDpadHeld()
				{
					if(GPU.controller == undefined)	
						return false;
					return GPU.controller.buttons[15].pressed;
				}

				UpDpadHeld()
				{
					if(GPU.controller == undefined)	
						return false;
					return GPU.controller.buttons[12].pressed;
				}

				DownDpadHeld()
				{
					if(GPU.controller == undefined)	
						return false;
					return GPU.controller.buttons[13].pressed;
				}

				Update()
				{
					this.ApplySceneGraph();
					this.transform.doRotations(this.rot);

					this.localPos[0] += this.vel[0];
					this.localPos[1] += this.vel[1];
					this.localPos[2] += this.vel[2];										

					this.vel[0] *= 0.98;
					this.vel[1] *= 0.98;
					this.vel[2] *= 0.98;					

					var leftX = this.LeftStickX();
					var leftY = this.LeftStickY();
					var rightX = this.RightStickX();
					var rightY = this.RightStickY();

					// console.log("leftStick (" + leftX + ", " + leftY + ")");
					// console.log("rightStick (" + rightX + ", " + rightY + ")");

					//if a stick is being held
					var rotIntensity = (math.abs(leftX) > this.stickDeadzone) ? math.abs(leftX) : 1.0;
					if(GPU.CheckKey('D') || this.LeftStickX() > this.stickDeadzone || this.RightDpadHeld())
						this.rot[1] += this.rotSpeed * rotIntensity;
					if(GPU.CheckKey('A') || this.LeftStickX() < -this.stickDeadzone || this.LeftDpadHeld())
						this.rot[1] -= this.rotSpeed * rotIntensity;
					
					var moveIntensity = (math.abs(leftY) > this.stickDeadzone) ? math.abs(leftY) : 1.0;
					if(GPU.CheckKey('W') || this.LeftStickY() > this.stickDeadzone || this.UpDpadHeld())
					{
						this.localPos[0] += this.transform.forward[0] * this.moveSpeed * moveIntensity;
						this.localPos[1] += this.transform.forward[1] * this.moveSpeed * moveIntensity;
						this.localPos[2] += this.transform.forward[2] * this.moveSpeed * moveIntensity;
					}
					if(GPU.CheckKey('S') || this.LeftStickY() < -this.stickDeadzone || this.DownDpadHeld())
					{
						this.localPos[0] -= this.transform.forward[0] * this.moveSpeed * moveIntensity;
						this.localPos[1] -= this.transform.forward[1] * this.moveSpeed * moveIntensity;
						this.localPos[2] -= this.transform.forward[2] * this.moveSpeed * moveIntensity;
					}
					if(GPU.CheckKey('Z') || this.LeftTriggerHeld())
					{
						this.localPos[1] -= this.elevateSpeed;
					}
					if(GPU.CheckKey('X') || this.RightTriggerHeld())
					{
						this.localPos[1] += this.elevateSpeed;
					}

					//STRAFE CONTROLS
					//Left key pressed. idk why left key is % with Towle's code
					var strafeIntensity = (math.abs(rightX) > this.stickDeadzone) ? math.abs(rightX) : 1.0;
					if(GPU.CheckKey('%') || this.RightStickX() < -this.stickDeadzone)
					{						
						this.localPos[0] -= this.strafeSpeed * this.transform.right[0] * strafeIntensity;
						this.localPos[1] -= this.strafeSpeed * this.transform.right[1] * strafeIntensity;
						this.localPos[2] -= this.strafeSpeed * this.transform.right[2] * strafeIntensity;
					}
					//Right key pressed. this is right key apparently
					if(GPU.CheckKey('\'') || this.RightStickX() > this.stickDeadzone)
					{						
						this.localPos[0] += this.strafeSpeed * this.transform.right[0] * strafeIntensity;
						this.localPos[1] += this.strafeSpeed * this.transform.right[1] * strafeIntensity;
						this.localPos[2] += this.strafeSpeed * this.transform.right[2] * strafeIntensity;
					}					
					
					if(GPU.controller != undefined)
					{
						const A = GPU.controller.buttons[0];
						const B = GPU.controller.buttons[1];
						const X = GPU.controller.buttons[2];
						const Y = GPU.controller.buttons[3];
						//these buttons correspond to xbox controller buttons
						if(A.pressed)						
							console.log("pressed A");						
						if(B.pressed)						
							console.log("pressed B");						
						if(X.pressed)						
							console.log("pressed X");						
						if(Y.pressed)					
							console.log("pressed Y");						
					}
				}

				Render(commandPass)
				{					
					commandPass.setBindGroup(1, this.camGroup);
					GPU.device.queue.writeBuffer(this.camBuff, 0, new Float32Array(this.pos));
					GPU.device.queue.writeBuffer(this.camBuff, 16, new Float32Array(this.rot));
				}
			}

			class Smoke extends GameObject
			{
				constructor(pos, rot, scale, fade=0, rawTexture, normalMap)
				{
					super(pos, rot, scale);				

					this.fade = fade;

					let maxDim = 1;
					let maxUV = 2;
					//these triangles form a square, which is the area for the fire "texture"				
					this.vertices = new Float32Array([
						 -maxDim,maxDim,0, 0,0,0, -maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
						-maxDim,-maxDim,0, 0,0,0, -maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						  maxDim,maxDim,0, 0,0,0,  maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
						 
						-maxDim,-maxDim,0, 0,0,0,  maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						 maxDim,-maxDim,0, 0,0,0, -maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						  maxDim,maxDim,0, 0,0,0, -maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
					]);
					
					this.vertexBuffer = GPU.device.createBuffer({
						label: "verticeBuffer",
						size: this.vertices.byteLength,
						usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.vertexBuffer, 0, this.vertices);
					
					if(this.fade == 1)
					{
						this.timer = 0.0;
					}
					else
					{
						let randStartTime = math.random()*100;
						this.timer = randStartTime;
					}
					
					this.billboardGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(0),
						label: "billboardGroup",
						entries:
						[
							{ binding: 0, resource: {buffer: this.uniformBuffer}},
							{ binding: 1, resource: {buffer: GPU.lightBuffer}},
						],
					});					
					
					this.SetupTextures(rawTexture, normalMap);
					this.textureBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(2),
						label: 'customObjTextureGroup',
						entries:	
						[																
							{ binding: 0, resource: this.textureObj.createView() },							
							{ binding: 1, resource: GPU.sampler },
							{ binding: 2, resource: this.normalTextureObj.createView() },
						],
					});					
										
					//assumes camera has already been made
					this.camera = GPU.GetObjectOfType(Camera);
										
					//set isSmoke to true in the shader
					GPU.device.queue.writeBuffer(this.uniformBuffer, 128, new Uint32Array([1]));
				}												
				
				Update()
				{					
					this.ApplySceneGraph();
					this.timer += (1/60);								
					
					//make flame face camera for billboarded effect if parent is null, otherwise, fire takes care of it
					if(this.parent == null)
						this.localRot[1] = this.camera.rot[1];

					this.transform.doRotations(this.localRot);
					
					// If we want smoke to fade, then wait 0.5 secs
					if(this.fade == 1 && this.timer >= 0.5)
					{
						// shrink the smoke
						this.localScale[0] -= 0.02;
						this.localScale[1] -= 0.02;
						this.localScale[2] -= 0.02;
						
						if (this.localScale[1] <= 0)
						{
							GPU.DestroyObject(this.id);
						}
					}
				}				
											
				Render(commandPass)
				{
					this.ParticleDraw(commandPass);
				}
			}
			
			class Flame extends GameObject
			{
				constructor(pos, rot, scale)
				{
					super(pos, rot, scale);	
										
					//these triangles form a square, which is the area for the fire "texture"
					let maxDim = 0.5;
					let maxUV = 1;
					this.vertices = new Float32Array([
						 -maxDim,maxDim,0, 0,0,0, -maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
						-maxDim,-maxDim,0, 0,0,0, -maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						  maxDim,maxDim,0, 0,0,0,  maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
						 
						-maxDim,-maxDim,0, 0,0,0,  maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						 maxDim,-maxDim,0, 0,0,0, -maxUV,-maxUV, 0,0,0,0,0,0,0,0,0,0,
						  maxDim,maxDim,0, 0,0,0, -maxUV, maxUV, 0,0,0,0,0,0,0,0,0,0,
					]);
					
					this.vertexBuffer = GPU.device.createBuffer({
						label: "verticeBuffer",
						size: this.vertices.byteLength,
						usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
					});
					GPU.device.queue.writeBuffer(this.vertexBuffer, 0, this.vertices);

					let randStartTime = math.random()*100;
					this.timer = randStartTime;
					
					this.billboardGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(0),
						label: "flameGroup",
						entries:
						[
							{ binding: 0, resource: {buffer: this.uniformBuffer}},
							{ binding: 1, resource: {buffer: GPU.lightBuffer}},
						],
					});					
					
					//even though fire doesn't use texture bindings, the group needs to be bound since
					//group(0) interacts with the textures in group(2) in the shader
					this.SetupTextures(undefined, undefined);
					this.textureBindGroup = GPU.device.createBindGroup
					({
						layout: GPU.pipeline.getBindGroupLayout(2),
						label: 'customObjTextureGroup',
						entries:
						[																
							{ binding: 0, resource: this.textureObj.createView() },			
							{ binding: 1, resource: GPU.sampler },
							{ binding: 2, resource: this.normalTextureObj.createView() },
						],
					});
					
					this.flameSpeedPerSecond = 1.3;					
					this.camera = GPU.GetObjectOfType(Camera);					
					
					//set isFire to true in the shader
					GPU.device.queue.writeBuffer(this.uniformBuffer, 124, new Uint32Array([1]));			

					this.smoke = GPU.CreateObject(1, Smoke, [0,1.3,0], [0,0,0], [1, 1, 1], 0, 0, 0, 0);
					this.smoke.SetParent(this);
				}																				

				SetGoalPos(goalPos)
				{											
					this.goalPos = goalPos;
					//console.log("goalPos: " + goalPos);

					this.burnDistance = this.VectorDistance(this.pos, goalPos);
					this.ropeBurnTime = this.burnDistance / this.flameSpeedPerSecond;

					this.xChangeToGoal = goalPos[0] - this.pos[0];
					this.yChangeToGoal = goalPos[1] - this.pos[1];
					this.zChangeToGoal = goalPos[2] - this.pos[2];
				}

				//sets goal pos to rightmost goal vertice found
				StartRope(rope)
				{
					this.SetParent(rope);
					//need to do this otherwise the flame's transform and goal is messed up lol
					this.ApplySceneGraph();

					this.pathPositions = rope.GetSortedPathPositions();

					this.goalIdx = this.pathPositions.length-1;
					this.goalPos = this.pathPositions[this.goalIdx];
					this.SetGoalPos(this.goalPos);
				}
				
				Update()
				{
					this.ApplySceneGraph();
					this.timer += (1/60);

					//make flame face camera for billboarded effect
					this.localRot[1] = this.camera.rot[1];
					this.transform.doRotations(this.localRot);			
					
					if(this.goalPos == undefined)
						return;

					if(this.VectorDistance(this.pos, this.goalPos) > 0.01)
					{
						//ex: say ropeBurn time is 5 seconds and xChangeToGoal is 10.
						//x += (1/60) * (10/5), //x changes by 2 every second, moves x by 10 in 5 seconds!						
						this.localPos[0] += (1/60) * (this.xChangeToGoal/this.ropeBurnTime);
						this.localPos[1] += (1/60) * (this.yChangeToGoal/this.ropeBurnTime);
						this.localPos[2] += (1/60) * (this.zChangeToGoal/this.ropeBurnTime);					
					}
					else
					{
						this.goalIdx--;
						if(this.goalIdx < 0)
						{
							this.parent.parent.StartFlashing();
							GPU.DestroyObject(this.smoke.id);
							GPU.DestroyObject(this.id);
						}
						else													
						{
							this.SetGoalPos(this.pathPositions[this.goalIdx]);
						}
					}					

					if(this.parent == undefined)
						return;

					//need to use rope's uniform buffer so that isRope in fragment shader has access to flame pos
					GPU.device.queue.writeBuffer(this.parent.uniformBuffer, 144, new Float32Array(this.pos));
				}
											
				Render(commandPass)
				{
					this.ParticleDraw(commandPass);
				}
			}

			class Rope extends CustomObj
			{
				constructor(parserData, pos, rot, scale)
				{
					super(parserData, undefined, undefined, pos, rot, scale);
					//set isRope to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 132, new Uint32Array([1])); 					
																					
					this.burnPositions = this.GetRopeEdges();
					this.leftmostBurnPos = this.burnPositions[0];
					this.rightmostBurnPos = this.burnPositions[1];														
					
					this.camera = GPU.GetObjectOfType(Camera);
					this.litFire = 0; // 0 if not, 1 if you have lit the fire

					//if firePos isn't initialized in the shader, it will be 0,0,0 and hide the rope
					let dummyFirePos = [9999,9999,9999];
					GPU.device.queue.writeBuffer(this.uniformBuffer, 144, new Float32Array(dummyFirePos));

					this.ropeRightEnd = [this.rightmostBurnPos[0], this.rightmostBurnPos[1], this.pos[2]];	
					
					//since flame hasn't been made yet, initialize flamePos in the shader so rope isn't invisible
					GPU.device.queue.writeBuffer(this.uniformBuffer, 144, new Float32Array([9000,9999,9999]));
				}								

				GetSortedPathPositions()
				{
					let positions = [];
					let reachedPath = false;					
					for(const line of window.rope1.split("\n"))
					{						
						if(line.substring(0,6) == "o Vert")					
							reachedPath = true;																			

						if(reachedPath && line[0] == "v")
						{
							let position = line.substring(2).split(' ');
							
							position[0] *= this.localScale[0];
							position[1] *= this.localScale[1];
							position[2] *= this.localScale[2];
							
							//this.pos is already accurate because of scene graph, so don't add parent positions
							position[0] += this.pos[0];
							position[1] += this.pos[1];
							position[2] += this.pos[2];														

							//position[0] *= math.cos(this.rot[2]);
							//THIS WILL BREAK LATER IF POSITION[0] IS NOT THE HALF LENGTH OF THE ROPE
							//position[1] = position[0] * math.tan(this.rot[2]);
							
							positions.push([position[0], position[1], position[2]]);							
						}
					}
					positions = this.SortByX(positions);
					console.log("rightmost pathPosition: " + positions[positions.length-1]);
					return positions;
				}
								
				GetRopeEdges()
				{
					let leftmostPos = [9999, 0, 0];
					let rightmostPos = [-9999, 0, 0];									
					for(let i = 0; i < this.vertices.length; i += GPU.vertexStride)
					{									
						if(this.vertices[i] < leftmostPos[0])
						{
							leftmostPos[0] = this.vertices[i];
							leftmostPos[1] = this.vertices[i+1];
							leftmostPos[2] = this.vertices[i+2];
						}
						if(this.vertices[i] > rightmostPos[0])
						{
							rightmostPos[0] = this.vertices[i];
							rightmostPos[1] = this.vertices[i+1];
							rightmostPos[2] = this.vertices[i+2];
						}						
					}

					leftmostPos[0] *= this.localScale[0];
					leftmostPos[1] *= this.localScale[1];
					leftmostPos[2] *= this.localScale[2];

					leftmostPos[0] += this.pos[0];
					leftmostPos[1] += this.pos[1];
					leftmostPos[2] += this.pos[2];	
					
					leftmostPos[0] *= math.cos(this.rot[2]);
					leftmostPos[1] = leftmostPos[0] * math.tan(this.rot[2]);

					rightmostPos[0] += this.pos[0];
					rightmostPos[1] += this.pos[1];
					rightmostPos[2] += this.pos[2];

					rightmostPos[0] *= this.localScale[0];
					rightmostPos[1] *= this.localScale[1];
					rightmostPos[2] *= this.localScale[2];
															
					//rightmostPos[0] *= math.cos(this.rot[2]);
					//tan(theta) = y/x, y = x * tan(theta), x = halfLength of rope
					//rightmostPos[1] = rightmostPos[0] * math.tan(this.rot[2]);
					
					// console.log("leftmost actual rope pos: " + leftmostPos);
					// console.log("rightmost actual rope pos: " + rightmostPos);
					
					this.ropeLength = this.localScale[0] * (rightmostPos[0] - leftmostPos[0]);
					return [leftmostPos, rightmostPos];
				}				

				Update()
				{
					this.ApplySceneGraph();
					
					if(this.litFire == 0)
					{
						this.distFromCamera = this.VectorDistance(this.pos, this.camera.pos);
						// Certain radius from camera
						if (this.distFromCamera <= 4) 
						{
							// Player presses 'E' to light fire
							//Use optional chaining to exit if controller is null
							if(GPU.CheckKey('E') || GPU.controller?.buttons[0].pressed) 
							{
								this.litFire = 1;
								var spawnPos = this.rightmostBurnPos;
								spawnPos[2] = -0.1;								
								var flame = GPU.CreateObject(0, Flame, spawnPos, [0,0,0]);
								flame.StartRope(this);
							}
						}
					}										
				}

				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			class Tnt extends CustomObj
			{
				static numTnt = 0;

				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{					
					super(parserData, rawTexture, normalMap, pos, rot, scale);
					this.flashTimer = 0.0;
					this.flashInterval = 0.15;
					this.flashOn = 1;
					this.explodeTimer = 2;
					this.isFlashing = false;	
					Tnt.numTnt++;
					this.tntIdx = Tnt.numTnt - 1;				

					//set usingTexture to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 112, new Uint32Array([1]));													
										
					//set isLaunchable to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 160, new Uint32Array([1]));
					this.vel = [0,0,0];
					
					console.log("parse vertices for rope");
					var result = ParseVertices(window.rope1, window.rope1Mtl);
					//keep scale as 1,1,1 for now otherwise flame is messed up since it's a child
					var rope = GPU.CreateObject(1, Rope, [0,0,0], [0,0,0], [1,1,1], result);					
					rope.SetParent(this);					
				}

				SortByTntIdx(tntList)
				{					
					for(let i = 0; i < tntList.length; i++)
					{
						for(let j = i+1; j < tntList.length; j++)
						{
							if(tntList[j].tntIdx < tntList[i].tntIdx)
							{
								var temp = tntList[j];
								tntList[j] = tntList[i];
								tntList[i] = tntList[j];	
							}
						}
					}										
					return tntList;
				}				

				LaunchObjects()
				{
					//this is after all constructors have ran, so this includes the current tnt
					let launchables = GPU.GetObjectsOfType(Tnt);
					let camera = GPU.GetObjectOfType(Camera);
					launchables.push(camera);
					
					//remove current tnt
					for(let i = 0; i < launchables.length; i++)
					{
						if(launchables[i] == this)
							launchables.splice(i, 1);
					}					

					for(let i = 0; i < launchables.length; i++)
					{
						var obj = launchables[i];
						if(obj == this)
							continue;
											
						var distToObj = this.VectorDistance(this.pos, obj.pos);
						var dirToObj = [];
						dirToObj[0] = obj.pos[0] - this.pos[0];
						dirToObj[1] = obj.pos[1] - this.pos[1];
						dirToObj[2] = obj.pos[2] - this.pos[2];
						dirToObj = this.Normalize(dirToObj);
						
						obj.vel[0] = ((dirToObj[0] * 80) / distToObj) * (1/60);
						obj.vel[1] = ((dirToObj[1] * 80) / distToObj) * (1/60);
						obj.vel[2] = ((dirToObj[2] * 80) / distToObj) * (1/60);

						if(obj instanceof Tnt)
						{
							obj.StartFlashing();
							obj.explodeTimer /= 2;
						}													
					}					
				}

				Update()
				{
					this.ApplySceneGraph();

					// this.localPos[0] += this.vel[0];
					// this.localPos[1] += this.vel[1];
					// this.localPos[2] += this.vel[2];

					this.vel[0] *= 0.99;
					this.vel[1] *= 0.99;
					this.vel[2] *= 0.99;

					this.flashTimer -= (1/60);
					if(this.flashTimer < 0 && this.isFlashing)
					{
						this.flashTimer = this.flashInterval;						
						(this.flashOn == 0) ? this.flashOn = 1 : this.flashOn = 0;
						//set isFlashing to true/false
						GPU.device.queue.writeBuffer(this.uniformBuffer, 156, new Uint32Array([this.flashOn]));
					}					

					if(this.isFlashing)
					{
						// EXPLODING
						this.explodeTimer -= (1/60);
						if(this.explodeTimer < 0)
						{													
							var smoke1 = GPU.CreateObject(
								1, 
								Smoke, 
								[this.pos[0], this.pos[1]+8, this.pos[2]],
								[0,0,0],
								[20, 20, 20], 
								0, 0, 0, 1);
							// Spawns 3 flames for now
							for(let i = 0; i < 3; i++)
							{
								let angle = math.random() * math.PI * 2;
								let r = math.sqrt(math.random()) * 4;
								
								let x = math.cos(angle) * r;
								let z = math.sin(angle) * r;

								var flame1 = GPU.CreateObject(
									0, 
									Flame, 
									[this.pos[0] + x, this.pos[1] - 6.2, this.pos[2] + z],
									[0,0,0],
									[2.5, 2.5, 2.5]);
							}
							
							SetExplodePos(this.pos, this.tntIdx);
							this.LaunchObjects();
							document.getElementById("boom").play();
							GPU.DestroyObject(this.id);
						}
					}
				}			

				StartFlashing()
				{													
					//set isFlashing to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 156, new Uint32Array([1]));					
					this.flashTimer = this.flashInterval;
					this.isFlashing = true;
				}
				
				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			class Crater extends CustomObj
			{
				constructor(parserData, rawTexture, normalMap, pos, rot, scale)
				{
					super(parserData, rawTexture, normalMap, pos, rot, scale);
					//set isCrater to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 224, new Uint32Array([1]));
					//set usingTexture to true
					GPU.device.queue.writeBuffer(this.uniformBuffer, 112, new Uint32Array([1]));

					this.InitExplodePositions();

					this.cam = GPU.GetObjectOfType(Camera);
				}

				InitExplodePositions()
				{	
					var i = 0;			
					for(i = 0; i < GPU.explodePos.length; i++)										
						GPU.device.queue.writeBuffer(this.uniformBuffer, 176 + (16 * i), new Float32Array(GPU.explodePos[i]));

					//after last known explodePos is initialized, use dummyPos for rest
					for(; i < 3; i++)
						GPU.device.queue.writeBuffer(this.uniformBuffer, 176 + (16 * i), new Float32Array([9999,9999,9999]));
				}

				Update()
				{
					this.ApplySceneGraph();

					var distToCam = this.VectorDistance(this.pos, this.cam.pos);
					if(distToCam < 8)					
						this.cam.inSphere = true;
					else
						this.cam.inSphere = false;
				}

				Render(commandPass)
				{
					this.IndexDraw(commandPass);
				}
			}

			//basically the main class
			class WebGPU
			{
				constructor()
				{				
					this.isReady = false;
					this.SetupGPU().then(() => {this.SlowStart();})
					this.specularity = 50.0;
					
					this.Visual = [];
					this.Solid = [];
					this.Trigger = [];
					this.ObjectCounter = 0;			
					this.prefab;

					this.vertexStride = 18;
					
					this.maxPointLights = 10;
					this.maxDirLights = 10;
					this.maxSpotLights = 10;

					this.numLights = 0;
					this.numPointLights = 0;
					this.numDirLights = 0;
					this.numSpotLights = 0;
										
					this.Keys = [];
					this.explodePos = []; //this is actually a 2d array, but don't want to set it as [[]] since that makes its length=1 on startup
					
					//2d array, with each elements being the list of objects at that pos
					this.cellGrid = [[]];
					this.resolution = window.innerHeight / window.innerWidth;
				}

				async SlowStart()
				{					
					//you can specify less parameters than the function defines and JS will still run it
					var camera = this.CreateObject(0, Camera, [3,-3,-2], [0,0,0]);										

					var pointLight;
					for(let i = 0; i < 5; i++)
					{									
						console.log("creating point light...");
						pointLight = this.CreateObject(0, PointLight, [0+i*8,2, 0], [0,0,0]);
						pointLight.color = [0.1, 0.1, 0.1];

						// var flame = this.CreateObject(0, Flame, [0,0,0], [0,0,0]);
						// flame.SetParent(pointLight);
						
						// var result = ParseVertices(window.discoBall, window.discoBallMtl);
						// var discoBall = GPU.CreateObject(1, CustomObj, [0.0, 0, 0], [0,1.5,0], [1,1,1], result);
					}

					for(let i = 0; i < 3; i++)
					{
						console.log("creating spotlight...");
						var light = this.CreateObject(0, SpotLight, [-5+(i*6),-1.2,0], [0.5,0,0]);
						light.color = [i/3, 0, 0.5];
												
						// var result = ParseVertices(window.spotlight, window.spotlightMtl);
						// var spotlight = GPU.CreateObject(1, CustomObj, [i*2, 2, 1.5], [0,0,0], [0.5,0.5,0.5], result);
					}		
					var l = this.CreateObject(0, DirectionalLight, [5, 5.0, 0], [0,3,0]);
					l.color = [0.15,0.15,0.15];

					console.log("parse vertices for ground");
					var result = ParseVertices(window.ground, window.groundMtl);
					var ground = GPU.CreateObject(1, CustomObj, [0,-5.5,1.1], [0,0,0], [15,15,15], result, window.grassTexture, window.grassNormals);					
					ground.specularity = 105;

					console.log("parse vertices for house");
					var result = ParseVertices(window.house, window.houseMtl);
					var house = GPU.CreateObject(1, CustomObj, [0.2,0.2,0.2], [0,0,0], [1,1,1], result, window.woodTexture, window.woodNormals);
					house.SetParent(ground);
					house.specularity = 100;
					
					console.log("parse vertices for wooden sign");
					var result = ParseVertices(window.woodSign, window.woodSignMtl);
					var woodSign = GPU.CreateObject(1, CustomObj, [-1.5, -5.5, -4], [0,25,0], [1,1,1], result, window.woodSignTexture, window.woodNormals);
					woodSign.specularity = 120;
							
					console.log("parse vertices for tree");
					var result = ParseVertices(window.tree, window.treeMtl);
					var tree = GPU.CreateObject(1, CustomObj, [0.8,0.25,0], [0,0,0], [1,1,1], result, window.treeTexture, window.treeNormals);
					tree.SetParent(ground);
					tree.specularity = 100;

					console.log("parse vertices for sphereTree");
					var result = ParseVertices(window.sphereTree, window.sphereTreeMtl);
					var sphereTree = GPU.CreateObject(1, CustomObj, [-0.3, 0.19, -0.4], [0,0,0], [0.2,0.2,0.2], result, window.treeTexture, window.treeNormals);					
					sphereTree.SetParent(ground);
					sphereTree.specularity = 100;
										
					console.log("parse vertices for sun");	
					var result = ParseVertices(window.sun, window.sunMtl);
					var sun = GPU.CreateObject(1, CustomObj, [0.9, 1, 1], [0,0,0], [1,1,1], result);
					sun.specularity = 100;					

					console.log("parse vertices for cube");
					var result = ParseVertices(window.cube, window.cubeMtl);
					var cube = GPU.CreateObject(1, CustomObj, [0.0, -2, 3], [0,0,0], [1,1,1], result, window.spiralTexture, window.spiralNormals);
					cube.specularity = 100;										
					
					// tnt Object
					//tnt needs to be made near the end of slow start so it can set explodePos on all objects
					console.log("parse vertices for tnt");
					var result = ParseVertices(window.tnt, window.tntMtl);
					var tnt = GPU.CreateObject(1, Tnt, [4, -4, 0], [0,0,0], [1,1,1], result, window.tntTexture);
					//for some reason adding this tnt messes up crater
					var tnt2 = GPU.CreateObject(1, Tnt, [12, -4, 0], [0,0,0], [1,1,1], result, window.tntTexture);
					//var tnt2 = GPU.CreateObject(1, Tnt, [-12, -2, 0], [0,0,0], [1,1,1], result, window.tntTexture);
					var tnt3 = GPU.CreateObject(1, Tnt, [23, -4, 0], [0,0,0], [1,1,1], result, window.tntTexture);

					let dummyPos = [9999, 9999, 9999];
					InitExplodePositions(dummyPos);

					this.startTime = performance.now();
					this.loops = 0;
					requestAnimationFrame(FrameUpdate);
				}		

				//need to fetch the controller every frame or the input does not update
				GetControllerInput()
				{
					const controllers = navigator.getGamepads();
					if(controllers[0] != undefined)
						this.controller = controllers[0];
				}

				GetObjectOfType(type)
				{
					var object;
					for(var i in this.Visual)
					{
						if(this.Visual[i] instanceof type)						
							return this.Visual[i];
					}

					for(var i in this.Solid)
					{
						if(this.Solid[i] instanceof type)
							return this.Solid[i];
					}

					for(var i in this.Trigger)
					{
						if(this.Trigger[i] instanceof type)						
							return this.Trigger[i];
					}
					return undefined;
				}
				
				GetObjectsOfType(type)
				{
					let objects = [];
					for(var i in this.Visual)
					{
						if(this.Visual[i] instanceof type)						
							objects.push(this.Visual[i]);			
					}

					for(var i in this.Solid)
					{
						if(this.Solid[i] instanceof type)
							objects.push(this.Solid[i]);
					}

					for(var i in this.Trigger)
					{
						if(this.Trigger[i] instanceof type)						
							objects.push(this.Trigger[i]);
					}
					return objects;
				}
				
				UpdateAll()
				{					
					for(var i in this.Visual)				
						this.Visual[i].Update();
					for(var i in this.Solid)				
						this.Solid[i].Update();
					for(var i in this.Trigger)
						this.Trigger[i].Update();			
				}
				
				RenderAll(resolution)
				{										
					this.encoder = this.device.createCommandEncoder();
										
					this.mainPass = this.encoder.beginRenderPass
					({
						label: 'mainRenderPass',
						colorAttachments:
						[{
							view: this.context.getCurrentTexture().createView(),
							loadOp: "clear",
							clearValue: { r:0.0, g:0.8, b:1, a:1 },
							storeOp: "store"
						}],
						depthStencilAttachment: {
							view: this.depthTextureView,								
							depthClearValue: 1.0,
							depthLoadOp: "clear",
							depthStoreOp: "store",

							stencilClearValue: 0,
							stencilLoadOp: 'clear',
							stencilStoreOp: 'store',
						},
					});					
					this.mainPass.setPipeline(this.pipeline);
															
					//might change this order later if we want to fix the root of the smoke problem
					for(var i in this.Visual)
						this.Visual[i].Render(this.mainPass);
					for(var i in this.Solid)
						this.Solid[i].Render(this.mainPass);
					for(var i in this.Trigger)
						this.Trigger[i].Render(this.mainPass);					
					this.CheckResolution(resolution);

					this.mainPass.end();

					this.mainCommandBuffer = this.encoder.finish();
					this.device.queue.submit([this.mainCommandBuffer]);
				}				

				//update projection matrix in shader so the world doesn't look stretchedsda
				CheckResolution(ratio)
				{					
					//console.log("change resolution to: " + ratio);
					var offset = 228;
					for(var i in this.Visual)				
						GPU.device.queue.writeBuffer(this.Visual[i].uniformBuffer, offset, new Float32Array([ratio]));
					for(var i in this.Solid)				
						GPU.device.queue.writeBuffer(this.Solid[i].uniformBuffer, offset, new Float32Array([ratio]));
					for(var i in this.Trigger)
						GPU.device.queue.writeBuffer(this.Trigger[i].uniformBuffer, offset, new Float32Array([ratio]));
				}
				
				CreateObject(type, prefab, pos, rot, scale, parserData, texture, normalMap, fade)
				{			
					//type 0 = visual
					//type 1 = solid
					//type 2 = trigger										
					var temp;
					if(prefab == CustomObj || prefab == Tnt  || prefab == Crater)
						temp = new prefab(parserData, texture, normalMap, pos, rot, scale); //Yes this dark sorcery will work.
					else if (prefab == Rope)
						temp = new prefab(parserData, pos, rot, scale);
					else if (prefab == Smoke)
						temp = new prefab(pos, rot, scale, fade);
					else
						temp = new prefab(pos, rot, scale);

					var id = "ID"+this.ObjectCounter;
					this.ObjectCounter++;
					temp.id = id;
					temp.prefab = prefab;								

					switch(type)
					{
						case 0:
							this.Visual[id] = temp;
						break;
						case 1:
							this.Solid[id] = temp;
						break;
						case 2:
							this.Trigger[id] = temp;
						break;
						default:
						break;
					}
					return temp;
				}
				
				
				DestroyObject(id)
				{
					if(id in this.Visual)
						delete this.Visual[id];
					if(id in this.Solid)
						delete this.Solid[id];
					if(id in this.Trigger)			
						delete this.Trigger[id];
				}

				CheckKey(k)
				{
					//console.log(Object.getOwnPropertyNames(this.Keys)); // shows all hashmap entries
					if(k in this.Keys)					
						return this.Keys[k];					
					return false;
				}
				
				KeyDown(event)
				{
					this.Keys[String.fromCharCode(event.keyCode)] = true;			
				}
				
				KeyUp(event)
				{
					this.Keys[String.fromCharCode(event.keyCode)] = false;
				}
				
				MouseClick(event)
				{
					var rect = canvas.getBoundingClientRect();
					var realX = event.clientX - rect.left;
					var realY = event.clientY - rect.top;					
					var x = -1 + 2*realX/myCanvas.width;
					var y = -1 + 2*(myCanvas.height - realY)/myCanvas.height;
					//console.log(realX+","+realY);
					//console.log("The click occurred on "+x+","+y);
				}				
								
				static keyD(event)
				{
					GPU.KeyDown(event);
				}
				static keyU(event)
				{
					GPU.KeyUp(event);
				}

				static mouseH(event)
				{
					GPU.MouseClick(event);
				}																
							
				async SetupGPU()
				{			
					this.adapter = await navigator.gpu.requestAdapter(); 
					if (!this.adapter)
					{	
						throw new Error("No appropriate GPUAdapter found.");
					}
					
					this.device = await this.adapter.requestDevice(); 
					if (!this.device)
					{
						fail('need a browser that supports WebGPU'); 
						return;					
					}
					console.log("WebGPU device found!");
					
					this.canvas = document.querySelector('canvas');
					this.context = this.canvas.getContext('webgpu');
					this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
					this.context.configure
					(
						{
							device: this.device,
							format: this.presentationFormat,
						}
					);
					console.log("Created context with device and format");
					
					this.cellShaderModule = this.device.createShaderModule
					({
						label: "mainModule",						
						code: `	
						struct Uniforms
						{
							matrix: mat4x4<f32>, //offset 0
							rotation: vec3f, //offset 64
							
							Ka: vec3f, //offset 80
							Ks: vec3f, //offset 96
							shiny: f32, //offset 112
														
							usingTexture: u32,
							usingNormalMaps: u32,
														
							timer: f32, 
							isFire: u32,
							isSmoke: u32,
							isRope: u32,

							flamePos: vec3f,
							isFlashing: u32,							
							isLaunchable: u32, //if this is unitialized, assume object is static
							explodePos: array<vec3f, 3>,
							isCrater: u32,

							resolutionRatio: f32,
						};						
						@group(0) @binding(0) var<uniform> uni: Uniforms;			

						struct VertexOutput
						{
							@builtin(position) position: vec4f,
							@location(0) color: vec3f,	
							@location(1) texCoords: vec2f,
							@location(2) normal: vec4f,
							@location(3) Ka: vec3f,
							@location(4) Ks: vec3f,
							@location(5) shiny: f32,
							@location(6) worldSpace: vec3f,
							@location(7) vectorToCam: vec3f, //for specularity									
							@location(8) flameWorldPos: vec3f,
						};				

						struct PointLight
						{
							position: vec4f,
							color: vec4f,
						}

						struct SpotLight
						{
							position: vec4f,
							direction: vec3f,
							color: vec3f, //or intensity
						}

						struct DirLight
						{
							direction: vec3f,
							color: vec4f,
						}

						struct ComplexLightSystem
						{							
							ambient: f32, //occupies 4 bytes
							shiny: f32, //offset 4
							
							numLights: u32, //offset 8
							numPointLights: u32, //offset 12
							numSpotLights: u32, //offset 16
							numDirLights: u32, //offset 20

							pointLights: array<PointLight,10>, //offset 32, //336 = 32*10 + 16
							spotLights: array<SpotLight,10>, //offset 352
							dirLights: array<DirLight,10>, //offset 832
						}
						@group(0) @binding(1) var<uniform> lightSystem: ComplexLightSystem;						

						struct CameraInfo
						{
							translation: vec3f,
							rotation: vec3f,
						}
						@group(1) @binding(0) var<uniform> myCam: CameraInfo;

						@group(2) @binding(0) var texture: texture_2d<f32>;
						@group(2) @binding(1) var textureSampler: sampler;
						@group(2) @binding(2) var normalMap: texture_2d<f32>; //need this for normal map

						fn MoveCamera(vert: vec4f) -> vec4f
						{
							var translationM : mat4x4<f32> = mat4x4<f32>(
									vec4<f32>(1,0,0,0),
									vec4<f32>(0,1,0,0),
									vec4<f32>(0,0,1,0),
									vec4<f32>(-1.0*myCam.translation.x, -1.0*myCam.translation.y, -1.0*myCam.translation.z, 1)
								);									
							
							//rotate world opposite of camera
							var c : vec3f = cos(-1.0*myCam.rotation);
							var s : vec3f = sin(-1.0*myCam.rotation);
							var rotM : mat4x4<f32> = mat4x4<f32>(
								vec4<f32>(c.y, 0.0, -s.y, 0.0),
								vec4<f32>(0.0, 1.0, 0.0, 0.0),
								vec4<f32>(s.y, 0.0, c.y, 0.0),
								vec4<f32>(0.0, 0.0, 0.0, 1.0),
							);

							//make everything orbit around camera
							return rotM * translationM * vert;
						}

						fn PerspectiveProjection(vert: vec4f) -> vec4f
						{
							var n: f32 = 0.001;
							var r: f32 = 0.001;
							var t: f32 = 0.001;
							var f: f32 = 5000.0;

							//column-major
							var perspectiveM : mat4x4<f32> = mat4x4<f32>(
									vec4<f32>(uni.resolutionRatio * n/r,0,0,0), //uni.resolutionRatio * 
									vec4<f32>(0, n/t, 0,0),
									vec4<f32>(0,0,(f+n)/(f-n),1),
									vec4<f32>(0,0,2*f*n/(f-n),1),
								);

							return perspectiveM * vert;
						}

						fn reflectVec(I: vec3<f32>, N: vec3<f32>) -> vec3<f32>
						{
							return I - 2.0 * dot(N, I) * N;	
						}

						//blinn phong half vector
						fn halfVec(L: vec3<f32>, V: vec3<f32>) -> vec3<f32>
						{
							return normalize(L + V);
						}

						//Rotate the object off the euler angle rotations.
						fn rotate(vert: vec4f) -> vec4f
						{
								var c : vec3f = cos(uni.rotation);
								var s : vec3f = sin(uni.rotation);

								var rotX : mat4x4<f32> = mat4x4<f32>(
								vec4<f32>( 1.0, 0.0, 0.0, 0.0 ),
								vec4<f32>( 0.0, c.x, -s.x, 0.0 ),
								vec4<f32>( 0.0, s.x,  c.x, 0.0 ),
								vec4<f32>( 0.0, 0.0, 0.0, 1.0 ));
						
								var rotY : mat4x4<f32> = mat4x4<f32>(
								vec4<f32>( c.y, 0.0, -s.y, 0.0 ),
								vec4<f32>( 0.0, 1.0,  0.0, 0.0 ),
								vec4<f32>( s.y, 0.0,  c.y, 0.0 ),
								vec4<f32>( 0.0, 0.0, 0.0, 1.0 ));								

								var rotZ : mat4x4<f32> = mat4x4<f32>(
								vec4<f32>( c.z, -s.z, 0.0, 0.0 ),
								vec4<f32>( s.z, c.z,  0.0, 0.0 ),
								vec4<f32>( 0.0, 0.0,  1.0, 0.0 ),
								vec4<f32>( 0.0, 0.0, 0.0, 1.0 ));
								
								return rotZ * rotY * rotX * vec4f(vert);
								//return rotY*vec4f(vert);
						}		

						//FIRE STUFF

						fn noise(pos: vec3<f32>) -> f32
						{
							var cell_coord = floor(pos);
							var hash_seed = dot(cell_coord, vec3<f32>(1.0, 57.0, 21.0)) + vec4<f32>(0.0, 27.0, 21.0, 78.0);
							var interp = cos((pos - cell_coord) * acos(-1.0)) * -0.5 + 0.5;
							hash_seed  = mix(sin(cos(hash_seed)*hash_seed), sin(cos(1+hash_seed)*(1+hash_seed)), interp.x);
							var blended_xy = mix(hash_seed.xz, hash_seed.yw, interp.y);
							hash_seed.x = blended_xy.x;
							hash_seed.y = blended_xy.y;
							return mix(hash_seed.x, hash_seed.y, interp.z);
						}

						fn sphere(pos: vec3<f32>, spr: vec4<f32>) -> f32
						{
							return length(spr.xyz - pos) - spr.w;
						}
								
						fn flame(pos: vec3<f32>) -> f32
						{							
							var iTime = uni.timer;
							var d = sphere(pos*vec3<f32>(1.0, 0.5, 1.0), vec4<f32>(0.0, -1.0, 0.0, 1.0));
							return d + (noise(pos + vec3<f32>(0.0, iTime * 2.0, 0.0)) + noise(pos * 3.0) * 0.5) * 0.25 * (pos.y);
						}

						fn scene(pos: vec3<f32>) -> f32
						{
							return min(100.0 - length(pos), abs(flame(pos)));
						}

						fn raymarch(ogPos: vec3<f32>, dir: vec3<f32>) -> vec4<f32>
						{
							var d = 0.0;
							var glow = 0.0;
							var eps = 0.02;	
							var pos = ogPos;					
							var glowed = 0u;
							
							for(var i = 0; i < 64; i++)
							{
								d = scene(pos) + eps;								
								pos = pos + d * dir;
								if(d > eps)
								{
									if(flame(pos) < 0.0)
									{
										glowed = 1u;
									}
																	
									if(glowed == 1u)
									{
										glow = f32(i) / 64.0;
									}
								}
							}
							return vec4<f32>(pos, glow);
						}
						
						// SMOKE STUFF
						
						fn smoke_density(pos: vec3<f32>) -> f32 {
							let t = uni.timer * 0.3;

							let base = 1.0 - smoothstep(0.0, 2, length(pos.xz));

							let n = noise(pos * 1.0 + vec3<f32>(0.0, t, 0.0));

							var d = base * n;

							d *= smoothstep(-1.0, 0.0, pos.y);
							d *= (2.5 - clamp(pos.y, 0.0, 2));

							return max(d, 0.0);
						}
						
						fn raymarch_smoke(org : vec3<f32>, dir : vec3<f32>) -> vec4<f32>
						{
							let steps = 64;
							let stepSize = 0.08;

							var pos = org;
							var alpha = 0.0;
							var color = vec3<f32>(0.0);

							for (var i = 0; i < steps; i = i + 1)
							{
								pos = pos + dir * stepSize;

								let density = smoke_density(pos);

								if (density <= 0.0001) 
								{ 
									continue; 
								}

								let a = density * 0.15;
								alpha = alpha + (1.0 - alpha) * a;

								color = color + vec3<f32>(0.6) * a;

								if (alpha > 0.98) 
								{ 
									break; 
								}
							}

							return vec4<f32>(color, alpha);
						}
						
						//the parameters correspond to the vertexBufferLayout object						
						@vertex						
						fn vertexMain(@location(0) pos: vec3f, @location(1) col: vec3f, @location(2) texCoords: vec2f, @location(3) normal: vec3f, @location(4) Ka: vec3f, @location(5) Ks: vec3f, @location(6) shiny: f32) -> VertexOutput
						{
							var vOutput: VertexOutput;
							let worldPos4: vec4<f32> = uni.matrix * vec4f(pos, 1.0);
							vOutput.worldSpace = worldPos4.xyz;
							vOutput.position = PerspectiveProjection(MoveCamera(worldPos4));														

							//may need an array of flame positions later
							vOutput.flameWorldPos = uni.flamePos;

							vOutput.normal = rotate(vec4f(normal, 0.0));
							vOutput.vectorToCam = myCam.translation - vOutput.worldSpace.xyz;

							vOutput.Ka = Ka;
							vOutput.Ks = Ks;
							vOutput.shiny = shiny;
														
							vOutput.color = col;
							vOutput.texCoords = texCoords;

							if(uni.isFire == 1u || uni.isSmoke == 1u)
							{								
								//offset fire texture coords
								vOutput.texCoords = vOutput.texCoords * 0.5 + 0.5;
							}

							return vOutput;
						}
												
						@fragment
						fn fragmentMain(fsInput: VertexOutput) -> @location(0) vec4f
						{						
							//return vec4f(vec3f(uni.resolutionRatio), 1);

							//get the early returns out of the way first for better performance				
							if(uni.isFire == 1u)
							{
								var v = -1.0 + 2.0 * fsInput.texCoords.xy / 1.0;
								var org = vec3<f32>(0, -2, 4);
								var dir = normalize(vec3<f32>(v.x * 1.6, -v.y, -1.5));

								var pos = raymarch(org, dir);
								var glow = pos.w;

								var col = mix(vec4<f32>(1, 0.5, 0.1, 1), vec4<f32>(0.1, 0.5, 1, 1), pos.y * 0.02 + 0.4);
								var fragColor = mix(vec4<f32>(0), col, pow(glow*2, 4));
								fragColor.w = 1.0;
								if(glow < 0.05)
								{
									discard;
								}
								else if(fragColor.x < 0.9 && fragColor.y < 0.9 && fragColor.z < 0.9)
								{
									fragColor.x = 0.9;
								}
								return fragColor;
							}
							
							if(uni.isRope == 1u)
							{
								//flameWorldPos moves left. discard pixels as flameWorldPos reaches them
								if(fsInput.worldSpace.x + 0.05 > fsInput.flameWorldPos.x)
								{
									discard;
								}
							}
							
							if(uni.isFlashing == 1u)
							{
								return vec4f(1);
							}						

							var AMBIENT_TOTAL = fsInput.color * lightSystem.ambient;		
							var newNormal: vec3f = fsInput.normal.xyz;
							var normalizedNormal: vec3f = normalize(fsInput.normal.xyz);

							let dx: vec3f = normalize(dpdx(fsInput.worldSpace));
							let bitangent: vec3f = normalize(cross(normalizedNormal, dx));
							let tangent: vec3f = normalize(cross(bitangent, normalizedNormal));							

							//read tangent from file or manually calculate tangent?
							let TBN = mat3x3<f32>(tangent, bitangent, normalizedNormal); //basically a lookat matrix from surface, use vertice normal
							
							let normalMapColor: vec3f = textureSample(normalMap, textureSampler, fsInput.texCoords).rgb;
							let normalTangent: vec3f = normalMapColor * 2.0 - 1.0;
							var normalWS = normalize(TBN * normalTangent); //old texture example code

							//there's weird errors when using fsInput.worldSpace or textureSample near dpdx, so I'm setting this variable early
							let textureValues = textureSample(texture, textureSampler, fsInput.texCoords);
																																																						
							for(var i = 0u; i < 3u; i++)
							{							
								// hard coded explosion radius for now, might customize later							
								if(distance(fsInput.worldSpace, uni.explodePos[i]) < 7.92 && uni.isLaunchable == 0u && uni.isSmoke == 0u)
								{
									discard;
								}
							}

							//need to set explodePos for each new crater as it is created
							if(uni.isCrater == 1u && fsInput.worldSpace.y < -5)
							{
								return textureValues;
							}
							//discard top part of crater
							else if(uni.isCrater == 1u)
							{
								discard;
							}										

							if(uni.usingNormalMaps == 1u)
							{
								newNormal = normalWS;
							}															
						
							var lightPower: vec3f = vec3<f32>(0,0,0); //summation of all light power
							var specPower: vec3<f32>; //summation of all specularity light power
							var dirLight: vec3<f32>; //summation of all directional light power							

							lightPower = vec3(0,0,0);
							specPower = vec3(0,0,0);
							dirLight = vec3(0,0,0);

							var LPos: vec3<f32>; //normalized vector to the light
							var LPosSafe: vec3<f32>; //make sure lRaw is not 0
							var IL: f32; //illumination of light

							//for specularity
							var reflection: vec3<f32>;
							var halfVector: vec3<f32>;
							
							//for spotlight
							var focus: f32;
							var direction: vec3<f32> = vec3<f32>(1,-1,1);							

							for(var i = 0u; i < min(lightSystem.numPointLights, 10u); i++)
							{																			
								var light: PointLight; //specific light instance									
								light = lightSystem.pointLights[i];									

								//normalizing in vertex shader results in squarish edges
								LPos = normalize(light.position.xyz - fsInput.worldSpace).xyz;
								LPosSafe = LPos;

								// L = select(vec3<f32>(0,0,0,0),lRaw,all(lRaw != vec3<f32>(0.0)));
																
								//dividing by length gives light falloff, light intensity variable is the coefficient here
								IL = 5 * max( dot(normalize(newNormal.xyz),LPosSafe), 0.0 ) / (1 + length(light.position.xyz - fsInput.worldSpace));
								lightPower += light.color.xyz*IL;
								
								if(IL > 0.0)
								{									
									reflection = reflectVec(-normalize(light.position.xyz - fsInput.worldSpace), normalize(newNormal).xyz);
									halfVector = halfVec(-LPosSafe, normalize(fsInput.vectorToCam).xyz);
									specPower += pow(
														max( dot(normalize(reflection), normalize(fsInput.vectorToCam) ), 0),
													uni.shiny) * light.color.xyz;													
								}
							}

							var lightingFactor: f32;

							for(var i = 0u; i < min(lightSystem.numSpotLights, 10u); i++)
							{																											
								var light: SpotLight; //specific light instance								
								light = lightSystem.spotLights[i];																						

								focus = dot(normalize(light.position.xyz - fsInput.worldSpace), normalize(-1*light.direction));
								if(focus >= 0.88)
								{									
									lightPower += max(
														dot(	normalize(newNormal).xyz, 
																normalize(light.position.xyz - fsInput.worldSpace).xyz), 
														0.0
														) * light.color.xyz;
								}
							}
																							
							for(var i = 0u; i < min(lightSystem.numDirLights, 10u); i++)
							{																																				
								var light: DirLight;																	
								light = lightSystem.dirLights[i];													
								
								IL = max( dot(normalize(newNormal.xyz), normalize(light.direction)), 0.0 );
								dirLight += IL * light.color.xyz;
							}																																					

							if (uni.isSmoke == 1u)
							{
								var v = -1.0 + 2.0 * fsInput.texCoords.xy;
								var org = vec3<f32>(0.0, -2.0, 4.0);
								var dir = normalize(vec3<f32>(v.x * 1.6, -v.y, -1.5));

								let sm = raymarch_smoke(org, dir);

								if (sm.a < 0.01) {
									discard;
								}

								return sm;
															
								//return vec4f(1.0, 1.0, 1.0, 0.5);
							}							

							var textureUse : f32;
							textureUse = f32(uni.usingTexture);
							if(uni.usingTexture == 1u)
							{
								return vec4f(vec4f(uni.Ka.x, uni.Ka.y, uni.Ka.z, 1) * textureValues * lightSystem.ambient + vec4f(dirLight + lightPower + specPower, 1));
							}
							else
							{
								return vec4f(vec4f(uni.Ka.x, uni.Ka.y, uni.Ka.z, 1) * vec4(fsInput.color, 1) * lightSystem.ambient + vec4f(dirLight + lightPower + specPower, 1));
							}
						}`
					});
					console.log("Created simple shader");
					
					//BUFFER VARS
					
					this.lightBuffer = GPU.device.createBuffer({
						label: 'lightBuffer',
						size: 1152,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					});
					this.dummyUniformBuffer = GPU.device.createBuffer({
						label: 'dummyUniform',
						size: 112,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					});										
					this.uniformBuffer = GPU.device.createBuffer({
						label: 'dummyUniform',
						size: 192,
						usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					});
					//linear vs point sample distance for textures
					this.sampler = this.device.createSampler({
						addressModeU: 'repeat',
						addressMoveV: 'mirror-repeat',
						minFilter: 'nearest',
						maxFilter: 'linear',
					});				

					//LAYOUT VARS

					this.vertexBufferLayout =					
					{
						label: 'mainVertexBufferLayout',
						arrayStride: GPU.vertexStride*4,
						attributes:
						[					
							//position	
							{
								format: "float32x3", 
								offset:0, 
								shaderLocation:0,
							},
							//color
							{
								format: "float32x3", 
								offset:3*4, 
								shaderLocation:1,
							},
							//texture uv coords
							{
								format:"float32x2", 
								offset:6*4, 
								shaderLocation:2,
							},
							//normal
							{
								format:"float32x3",
								offset:8*4,
								shaderLocation:3,
							},
							//Ka
							{
								format:"float32x3",
								offset:11*4,
								shaderLocation:4,
							},
							//Ks
							{
								format:"float32x3",
								offset:14*4,
								shaderLocation:5,
							},
							//Ns
							{
								format:"float32",
								offset:17*4,
								shaderLocation:6,
							},
						],
					};										

					this.mainGroupLayout = this.device.createBindGroupLayout
					({
						label: 'mainGroupLayout',
						entries:
						[
							{
								binding: 0, //Uniform
								visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
								buffer: { type: 'uniform', }, 
							},
							{
								binding: 1, //ComplexLightSystem
								visibility: GPUShaderStage.FRAGMENT,
								buffer: { type: 'uniform', } 
							},							
						],
					});

					this.cameraGroupLayout = this.device.createBindGroupLayout
					({
						label: 'cameraGroupLayout',
						entries:
						[
							{
								binding: 0,
								visibility: GPUShaderStage.VERTEX,
								buffer: {type: 'uniform', },
							}
						]
					})

					this.textureGroupLayout = this.device.createBindGroupLayout
					({
						label: "textureGroupLayout",
						entries:
						[
							{
								binding: 0, //texture_2d
								visibility: GPUShaderStage.FRAGMENT,
								texture: {}, //sampleType: "float"
							},
							{
								binding: 1, //texture sampler
								visibility: GPUShaderStage.FRAGMENT,
								sampler: {}, //type: "filtering"
							},		
							{
								binding: 2, //texture sampler
								visibility: GPUShaderStage.FRAGMENT,
								texture: {}, //type: "filtering"
							},
						],
					});

					this.mainPipelineLayout = this.device.createPipelineLayout
					({
						label: 'mainPipelineLayout',
						bindGroupLayouts: [ this.mainGroupLayout, this.cameraGroupLayout, this.textureGroupLayout ]
					});									

					//PIPELINE VARS					
					
					this.pipeline = this.device.createRenderPipeline
					({
						label: "Main pipeline",
						layout: this.mainPipelineLayout, //layout: "auto",
						vertex: 
						{
							module: this.cellShaderModule,
							entryPoint: "vertexMain",
							buffers: [this.vertexBufferLayout],
						},
						fragment:
						{
							module: this.cellShaderModule,
							entryPoint: "fragmentMain",
							targets: [{
								format: this.presentationFormat,
								blend: {
									color: {
										srcFactor: "src-alpha",
										dstFactor: "one-minus-src-alpha",
										operation: "add",
									},
									alpha: {
									  srcFactor: "one",
									  dstFactor: "one-minus-src-alpha",
									  operation: "add",
									},
								},
								writeMask: GPUColorWrite.ALL,
								}]
						},
						primitive:
						{							
							topology: "triangle-list",
							cullMode: "none",							
							// topology: "triangle-strip",
							// stripIndexFormat: "uint16",
						},						
						depthStencil: {
							format: "depth24plus-stencil8",
							depthWriteEnabled: true,
							depthCompare: "less-equal",
						},						
					});
					console.log("Created pipeline");			

					this.depthTexture = this.device.createTexture({
						label: 'depthTexture',
						size: [this.canvas.width, this.canvas.height],
						format: "depth24plus-stencil8",
						usage: GPUTextureUsage.RENDER_ATTACHMENT,
					});
					this.depthTextureView = this.depthTexture.createView();
				}
			}							
			
			GPU = new WebGPU();
			var canvas = document.getElementById("myCanvas");			
			canvas.addEventListener("click", WebGPU.mouseH);

			window.onkeydown = WebGPU.keyD;
			window.onkeyup = WebGPU.keyU;	
			window.addEventListener("gamepadconnected", (e) =>
			{
				console.log("Controller connected: " + e.gamepad);			
			});

			window.addEventListener("resize", () =>
			{
				console.log("Window resized!");
				var ratio =  window.innerHeight / window.innerWidth;
				GPU.resolution = ratio;
			});
		</SCRIPT>
	</HEAD>
</HTML>